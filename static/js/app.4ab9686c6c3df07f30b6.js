webpackJsonp([1],{"0w3B":function(n,e){n.exports='<h1 id="vue-">Vue 项目实战学习笔记</h1>\n<h2 id="-canvas-">关于canvas贪吃蛇项目</h2>\n<ul>\n<li>我们在单组件中想引入音乐，视频时，需要把资源放在<code>static</code>文件夹下</li>\n<li><em>canvas</em>写贪吃蛇的时候，注意要给每个身体一个坐标。也就是蛇身体用数组表示</li>\n</ul>\n<h2 id="-vue-markdown">在vue中使用markdown</h2>\n<ul>\n<li><p>如果你想使用一个编辑器或者是在评论系统中支持 markdown。这个 package 的有点还是挺多了，比如默认就支持 emoji，这个就很完美啦！laravist 的新版就使用了 vue-markdown 来渲染评论。本文主要介绍了Vuejs 中使用 markdown的示例，小编觉得挺不错的，现在分享给大家，也给大家做个参考，希望能帮助到大家。</p>\n</li>\n<li><p>首先安装<code>npm install --save vue-markdown</code></p>\n</li>\n<li><p>也是很简单的，可以直接这样：</p>\n<ul>\n<li><pre><code class="language-js">import VueMarkdown from &#39;vue-markdown&#39;\n\nnew Vue({\n components: {\n  VueMarkdown\n\n }\n})</code></pre>\n</li>\n</ul>\n</li>\n<li><p>或者是这样，举一个具象化的例子是：比如我们有一个 Comment.vue 组件用来渲染评论，可以在这个组件中直接指明：</p>\n<ul>\n<li><p>```js\nimport VueMarkdown from &#39;vue-markdown&#39;;</p>\n<template>\n\n <p>\n\n<p>  <vue-markdown :source="comment.body"></vue-markdown></p>\n </p>\n\n</template>\n\n\n\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>export default { // ... other codes\n\n props:[&#39;comment&#39;],\n\n data(){  \n\n  return {\n\n   comment : this.comment\n\n  }\n\n }, \n\n components: {\n\n  VueMarkdown\n\n }, \n\n// ... other codes\n\n}\n```</code></pre><ul>\n<li><p>然后在渲染的时候这个：</p>\n<ul>\n<li><pre><code class="language-html">&lt;p class=&quot;comments&quot;&gt;\n\n &lt;p class=&quot;comments&quot; v-for=&quot;comment in comments&quot;&gt;\n\n  &lt;comment :comment=&quot;comment&quot;&gt;\n\n  &lt;/comment&gt;\n\n &lt;/p&gt;\n\n&lt;/p&gt;</code></pre>\n</li>\n<li></li>\n</ul>\n</li>\n</ul>\n'},"1P4l":function(n,e){},"8V2Q":function(n,e){},"901n":function(n,e){},"9lDK":function(n,e,t){n.exports='<h1 id="vue-js-three-days">Vue.js Three Days</h1>\n<ul>\n<li>扩展<ul>\n<li>axios发送ajax</li>\n<li>fetch发送ajax</li>\n<li>xhr.status 状态<ul>\n<li>100 准备阶段</li>\n<li>200成功</li>\n<li>300重定向或缓存</li>\n<li>400无法访问与拒绝访问</li>\n<li>500服务器错误</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="vue-js-">Vue.js 组件</h2>\n<h3 id="-">父子组件的通信</h3>\n<ul>\n<li><p>父组件中的数据，子组件中访问不到。（组件之间是解耦关系）</p>\n<ul>\n<li><p>通过props属性，由子组件向父组件请求数据（父组件向子组件传输数据）</p>\n<ul>\n<li><p>props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值。 </p>\n<ul>\n<li><blockquote>\n<p>{</p>\n<p>​    title:{</p>\n<p>​        tyle:String,</p>\n<p>​        defaulte:false</p>\n<p>​    }</p>\n<p>}</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>通过父组件获取的数据，子组件不能修改，这是单项数据流动。</p>\n</li>\n</ul>\n</li>\n<li><pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;\n    &lt;my-header :child-message=&quot;message&quot;&gt;&lt;/my-header&gt;\n&lt;/div&gt;\n&lt;script&gt;\n    //html属性不要出现驼峰写法，HTML5本身不区分大小写,建议使用-代替驼峰写法\n    //但是js环境中不支持-，所以要用驼峰写法。两者相等\n    //通过把父组件的数据挂载到子组件的标签中，子组件在通过props属性取到这个标签上的属性名，就得到了对应的键值对\n    var vm = new Vue({\n        el:&#39;#app&#39;,\n        data:{\n            message:&#39;我是来自父组件的问候&#39;\n        },\n        components:{\n            &#39;my-header&#39;:{\n                template:`&lt;div&gt;我是子组件，{{childMessage}}&lt;/div&gt;`,\n                props:[&#39;child-message&#39;]\n            }\n        }\n    })\n&lt;/script&gt;</code></pre>\n</li>\n<li><p>同样子组件的数据，父组件也访问不到</p>\n<ul>\n<li>通过自定义事件emit events触发来获取数据</li>\n<li>通过子组件获取的数据，父组件不能修改，这是单项数据流动。</li>\n</ul>\n</li>\n<li><pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;\n    我是父组件：{{message}}\n    &lt;my-header @custom-child-events=&quot;getChildInfo&quot;&gt;&lt;/my-header&gt;\n&lt;/div&gt;\n&lt;script&gt;\n    //html属性不要出现驼峰写法，HTML5本身不区分大小写,建议使用-代替驼峰写法\n    //但是js环境中不支持-，所以要用驼峰写法。两者相等\n\n    var vm = new Vue({\n        el:&#39;#app&#39;,\n        data:{\n            message:&#39;&#39;\n        },\n        methods:{\n            getChildInfo(res){\n                this.message = res\n            }\n        }\n        components:{\n            &#39;my-header&#39;:{\n                template:`&lt;div @click=&quot;shootInfo&quot;&gt;我是子组件:&lt;/div&gt;`,\n                data(){\n                    return {\n                       childMessage:&#39;来自子组件的问候&#39; \n                    }\n                },\n                 mothods:{\n                     shootInfo(){\n                            this.$emit(&#39;custom-child-events&#39;,this.childMessage)\n                             }\n                 }\n            }\n        }\n    })\n&lt;/script&gt;</code></pre>\n</li>\n<li><p>非父子组件通信</p>\n<ul>\n<li><p>祖孙通信和兄弟通信，等非父子通信一般用vuex来解决（简单）</p>\n</li>\n<li><p>祖孙组件通信</p>\n<ul>\n<li>先父子通信，在父子通信，一层层的传递。（麻烦）</li>\n</ul>\n</li>\n<li><p>非父子组件通过空实例通信</p>\n<ul>\n<li><pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;\n    &lt;my-header&gt;&lt;/my-header&gt;\n    &lt;my-list&gt;&lt;/my-list&gt;\n&lt;/div&gt;\n\n&lt;script&gt;\n    var bus = new Vue()//bus总线（空对象）\n    //bus.$on()绑定事件\n    //bus.$emit()触发事件\n    //为什么不用vm，而是用一个空对象，因为在vm创建的过程中首先就是绑定的事件，所以在参数列表中不能直接用vm引用的事件，是绑定不到vm上面的。\n\n    var vm = new Vue({\n        el:&#39;#app&#39;,\n        components:{\n            &#39;my-header&#39;:{\n                template:&#39;&lt;div&gt;{{message}}&lt;/div&gt;&#39;,\n                data(){\n                    return{\n                        message:&#39;&#39;\n                    }\n                },\n                mounted(){\n                    //在生命周期中绑定事件\n                    bus.$on(&#39;data-custom-events&#39;,(payload)=&gt;{\n                        this.message = payload\n                    })\n                }\n            },\n            &#39;my-list&#39;:{\n                template:&#39;&lt;div @click=&quot;handleChange&quot;&gt;{{info}}&lt;/div&gt;&#39;,\n                data(){\n                    return{\n                        info:&#39;非父子通信&#39;\n                    }\n                },\n                methods:{\n                    handleChange(evt){\n                        //触发点击事件时触发自定义事件，发送数据\n                        bus.$emit(&#39;data-custom-events&#39;,evt.target.innerHTML)\n                    }\n                }\n            }\n        }\n    })\n\n&lt;/script&gt;</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="vue-js-">Vue.js 组件的内容分发</h3>\n<ul>\n<li><p>内容分发：把组件标签内的内容，添加到指定的位置。</p>\n<ul>\n<li><p>默认组件标签内的内容不会被浏览器编译</p>\n</li>\n<li><p>利用插槽标签*<slot></slot>*</p>\n</li>\n<li><pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;\n    &lt;my-header&gt;\n        &lt;span slot=&quot;icon1&quot;&gt;插槽1&lt;/span&gt;\n        &lt;span slot=&quot;icon2&quot;&gt;插槽2&lt;/span&gt;\n    &lt;/my-header&gt;\n&lt;/div&gt;\n\n&lt;script&gt;\n    //通过给组件内的标签添加slot属性指定名字，在template的&lt;slot&gt;标签中添加name\n    var vm = new Vue({\n        el:&#39;#app&#39;,\n        components:{\n            &#39;my-header&#39;:{\n                template:&#39;&lt;div&gt;&lt;slot name=&quot;icon1&quot;&gt;我是插槽的默认值，如果找不到name=&quot;icon1&quot;的属性，我就会显示出来&lt;/slot&gt;{{message}}，&lt;solt name=&quot;icon2&quot;&gt;&lt;/solt&gt;&lt;/div&gt;&#39;,\n                data(){\n                    return{\n                        message:&#39;组件分发&#39;\n                    }\n                }\n            })</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="-">动态组件</h3>\n<ul>\n<li><p>vue中有许多自定义属性：<code>is</code> <code>key</code> <code>ref</code></p>\n</li>\n<li><p>vue中有许多自定义标签：<code>&lt;template&gt; &lt;transition&gt; &lt;component&gt;</code></p>\n</li>\n<li><p>所以我们可以通过<code>&lt;component&gt;</code>标签和<code>is</code>属性来实现动态标签</p>\n</li>\n<li><p>组件切换的时候，会全部摧毁重建（不会像标签一样进行复用）</p>\n<ul>\n<li>所以性能会受到影响</li>\n<li>用<code>&lt;keep-alive&gt;</code>标签解决这个问题：保存第一次渲染的组件到内存中，下一次去内存中读取组件（像vue对相同标签进行复用）。所以不会再触发组件的生命周期<ul>\n<li>但是会自动给组件添加两个其他的生命周期，针对缓存的生命周期<ul>\n<li><code>activated</code>在激活<code>&lt;keep-alive&gt;</code>时触发</li>\n<li><code>deactivated</code>在销毁<code>&lt;keep-alive&gt;</code>时触发</li>\n</ul>\n</li>\n<li>同样我们还可以给<code>&lt;keep-alive&gt;</code>标签一个<code>include</code>或者<code>exclude</code>属性来控制是否给某个组件缓存</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;\n\n        &lt;!-- &lt;tab1&gt;&lt;/tab1&gt;\n        &lt;tab2&gt;&lt;/tab2&gt;\n        &lt;tab3&gt;&lt;/tab3&gt; --&gt;\n\n        &lt;button @click=&quot;handleChange(1)&quot;&gt;TAB1&lt;/button&gt;\n        &lt;button @click=&quot;handleChange(2)&quot;&gt;TAB2&lt;/button&gt;\n        &lt;button @click=&quot;handleChange(3)&quot;&gt;TAB3&lt;/button&gt;\n\n        &lt;keep-alive&gt;\n            &lt;component :is=&quot;nowComponent&quot;&gt;&lt;/component&gt;\n        &lt;/keep-alive&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n\n    //1.动态组件：&lt;component&gt; 和 is属性(选择指定的组件) 配合使用的\n\n    //2.vue中有很多自定义标签：&lt;component&gt;、&lt;template&gt; 、&lt;transtion&gt; ...\n\n    //3.vue中有很多自定义属性：key属性、ref属性、is属性  ...\n\n    // 4. 组件切换的时候，会全部重新创建。\n    //     1. 性能会有一些小影响\n    //     2. 之前的内容不会保留，例如输入框里的内容。\n        //解决：&lt;keep-alive&gt; : 保留第一次渲染的组件到内存中，下一次去内存中读出这个缓存的组件。\n\n    var vm = new Vue({\n        el : &#39;#app&#39;,\n        data : {\n            nowComponent : &#39;tab1&#39;\n        },\n        components : {\n            &#39;tab1&#39; : {\n                template : &#39;&lt;div&gt;tab1:&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;&#39;\n            },\n            &#39;tab2&#39; : {\n                template : &#39;&lt;div&gt;tab2:&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;&#39;\n            },\n            &#39;tab3&#39; : {\n                template : &#39;&lt;div&gt;tab3:&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;&#39;\n            }\n        },\n        methods : {\n            handleChange(n){\n                this.nowComponent = &#39;tab&#39; + n;\n            }\n        }\n    });    \n\n    &lt;/script&gt;</code></pre>\n</li>\n</ul>\n<h2 id="vue-ref-">Vue 的<code>$ref</code>属性</h2>\n<ul>\n<li><p><code>$ref</code> 对DOM元素进行引用</p>\n<ul>\n<li><p>尽量少使用，vue是数据驱动，尽量避免DOM操作</p>\n</li>\n<li><pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;\n    &lt;input ref=&#39;val&#39; type=&quot;text&quot; /&gt;\n    &lt;button @click=&quot;getInfo&quot;&gt;\n        获取数据\n    &lt;/button&gt;\n&lt;/div&gt;\n&lt;script&gt;\n    var vm = new Vue({\n        el:&#39;#app&#39;,\n        methods:{\n            getInfo(){\n                console.log(this.$refs.val.value)//取的输入框的值\n            }\n        }\n    })\n&lt;/script&gt;</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="vue-js-">Vue.js 过度与动画</h2>\n<ul>\n<li><p>专门针对显示与隐藏操作的</p>\n</li>\n<li><p>通过<transition>标签添加过渡与动画</p>\n<ul>\n<li><p>图示</p>\n</li>\n<li><p><img src="'+t("p1f+")+'" alt=""></p>\n</li>\n<li><p>注意  *<em>v *</em>  是一个变量，就是<transition name="v">  </p>\n</li>\n<li><p><code>v-enter</code>  第0帧</p>\n</li>\n<li><p><code>v-enter-to</code>  第1帧-------最后1帧（动画消失）</p>\n</li>\n<li><p><code>v-enter-active</code>  动画全程都存在，所以这个属性上面可以写css的<code>animate</code></p>\n</li>\n<li><p><code>v-leave</code>  第0帧</p>\n</li>\n<li><p><code>v-leave-to</code>  第1帧-------最后1帧（动画消失）</p>\n</li>\n<li><p><code>v-leave-active</code>  动画全程都存在，所以这个属性上面可以写css的<code>animate</code></p>\n</li>\n<li><pre><code class="language-html">&lt;style&gt;\n    v-enter:{opcity:0};\n    v-enter-to:{opcity:1};//可以省略\n    v-enter-active:{transition:1s}//因为它全程都在，所以给它加过渡属性\n    v-leave:{opcity:1};\n    v-leave-to:{opcity:0};//可以省略\n    v-leave-active:{transition:1s}//因为它全程都在，所以给它加过渡属性\n&lt;/style&gt;\n&lt;transition name=&quot;v&quot;&gt;\n    &lt;div&gt;\n        我有背景色\n    &lt;/div&gt;\n&lt;/transition&gt;</code></pre>\n</li>\n</ul>\n</li>\n<li><p><strong>animate.css</strong>的使用</p>\n<ul>\n<li><p>一个专门做c3动画的库</p>\n</li>\n<li><p>引用css文件，在你想添加动画效果的元素上面添加 <code>class=&quot;animated xxxx infinite&quot;</code> 等<code>infinite</code>是选择动画是否无限</p>\n</li>\n<li><p>我们可以通过定义<transition>中的属性使用这个库</p>\n</li>\n<li><pre><code class="language-html">&lt;link rel=&quot;stylesheet&quot; href=&quot;./animate.css&quot;&gt;\n&lt;transition name=&quot;v&quot; leave-action-class=&quot;xxxx&quot; enter-action-class=&quot;xxxx&quot;&gt;\n    &lt;div class=&quot;animated&quot;&gt;\n        必须有animated\n    &lt;/div&gt;\n&lt;/transition&gt;</code></pre>\n</li>\n</ul>\n</li>\n<li><p><code>appear appear-active-class</code>在<transition>标签上添加这句话可以自动执行动画，不需要触发条件</p>\n</li>\n<li><p>多元素切换的时候，最好通过设置不同的<code>key</code>属性来区分相同标签名的元素，以避免vue的复用</p>\n</li>\n<li><p>我们同样可以通过在<transition>标签上添加属性<code>mode=&quot;in-out&quot;/mode=&quot;out-in&quot;</code>来控制先进行<em>enter</em>还是<em>leave</em></p>\n</li>\n<li><p>列表过渡（必须设置key属性）</p>\n<ul>\n<li><p>使用<transition-group>标签包裹列表标签</p>\n</li>\n<li><p><transition-group>默认会自动渲染到页面变成一个<span>标签，<transition>不会影响页面</p>\n</li>\n<li><p>我们可以通过给<transition-group>标签添加<code>tag</code>  属性来指定它变成的标签名</p>\n</li>\n<li><pre><code class="language-html">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;style&gt;\n    .slide-enter-active{ animation:.5s move linear; }\n    .slide-leave-active{ animation:.5s move linear reverse;}\n    @keyframes move{\n        0%{ transform : translateX(100px); opacity:0;}\n        100%{ transform : translateX(0); opacity:1;}\n    }\n    &lt;/style&gt;\n    &lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;app&quot;&gt;\n\n        &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt;&lt;button @click=&quot;handleAddMessage&quot;&gt;留言&lt;/button&gt;\n\n        &lt;transition-group tag=&quot;ul&quot; name=&quot;slide&quot;&gt; \n            &lt;li v-for=&quot;item,index in list&quot; :key=&quot;item.id&quot;&gt;{{ item.content }}  &lt;button @click=&quot;handleRemoveMessage(index)&quot;&gt;X&lt;/button&gt;&lt;/li&gt;\n        &lt;/transition-group&gt;\n\n        &lt;div&gt;总计：{{ list.length }}&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n\n    //1. &lt;transition-group&gt; : 默认会渲染成一个&lt;span&gt;标签\n    //2. tag属性：指定要渲染成的标签\n    var vm = new Vue({\n        el : &#39;#app&#39;,\n        data : {\n            isShow : true,\n            /*list : [&#39;默认的留言1&#39; , &#39;默认的留言2&#39;],*/\n            list : [\n                { &quot;id&quot; : 1 , &quot;content&quot; : &quot;默认的留言1&quot; },\n                { &quot;id&quot; : 2 , &quot;content&quot; : &quot;默认的留言2&quot; },\n                { &quot;id&quot; : 3 , &quot;content&quot; : &quot;默认的留言3&quot; }\n            ],\n            message : &#39;&#39;\n        },\n        methods : {\n            handleAddMessage(){\n                //this.list.unshift(this.message);\n                this.list.unshift({\n                    id : this.list.length + 1,\n                    content : this.message\n                });\n                this.message = &#39;&#39;;\n            },\n            handleRemoveMessage(index){\n                this.list.splice(index,1);\n            }\n        }\n    });\n\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n'},A28e:function(n,e){n.exports='<h1 id="vue-js-to-begin">vue.js To Begin</h1>\n<h2 id="-vue-js">初识vue.js</h2>\n<ol>\n<li><p>构建数据驱动的web应用开发框架，属于前端框架</p>\n</li>\n<li><p>声明式渲染，应对前后端分离的大趋势</p>\n<ol>\n<li><pre><code class="language-javascript">var message = &#39;hello world&#39;;\n&lt;div&gt;message&lt;/div&gt;  \n页面显示：&lt;div&gt;hello world&lt;/div&gt;</code></pre>\n</li>\n<li><p>声明式渲染，同样是响应式。</p>\n</li>\n<li><p>node项目用的是混合式开发。把前端的代码，和ejs结合在一起。</p>\n</li>\n</ol>\n</li>\n<li><p>渐进式框架，适应各种业务需求以及场景</p>\n<ol>\n<li>适合新手，同样适合有一定经验的开发人员。</li>\n<li>小型，中型，大型项目都可以采用VUE框架开发。</li>\n<li>渐进式框架：非常容易上手，渐进增强。</li>\n</ol>\n</li>\n<li><p>适合移动端开发，SPA页面，即单页开发</p>\n<ol>\n<li>移动端网路不是很稳定。期望项目制作为单页面，尽量避免跳转页面。</li>\n<li>SPA页面，即单页面开发，适用于vue.js框架。</li>\n</ol>\n</li>\n<li><p>快速交付，结合第三方ui框架</p>\n<ol>\n<li>一个项目，用jQuery开发和用vue开发的对比，vue会节省30%移上的代码。</li>\n<li>接口很多，可以结合很多UI框架。</li>\n<li>jQueryUI框架：easyUI，minUI等。</li>\n<li>vue相关UI框架：elementUI,minUI等。</li>\n<li>查阅vue官网自行寻找。</li>\n</ol>\n</li>\n<li><p>侧重于数据。不需要操作DOM，框架自动操作。</p>\n</li>\n</ol>\n<h2 id="-">设计模式</h2>\n<ul>\n<li>每一种语言都是设计模式。<ul>\n<li>前人总结的一种开发经验。</li>\n<li>23种设计模式（book）<ul>\n<li>例如观察者模式</li>\n<li>工厂模式</li>\n<li>适配器模式等等</li>\n</ul>\n</li>\n<li>架构的设计模式（不属于23种设计模式）<ul>\n<li>MVC<ul>\n<li>model数据 views视图 controller控制器<ul>\n<li>利用控制器把数据和视图链接在一起</li>\n<li>view代码多 model代码相对多 control代码少</li>\n<li>node项目</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>MVP<ul>\n<li>model数据 views视图 presenter提出者<ul>\n<li>model和view代码相对多。presenter代码最多</li>\n<li>jQuery项目</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>MVVM（vue.js）<ul>\n<li>vm数据视图层<ul>\n<li>每层代码都很少</li>\n<li>vue.js 帮我们实现了vm层</li>\n<li>vue,js帮我们做了所有的DOM操作</li>\n<li>利用了双向数据绑定（observer）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="-">开发环境搭建</h2>\n<ul>\n<li><p>vue.js v-2.*.*</p>\n</li>\n<li><p>声明式渲染</p>\n</li>\n<li><p>组件系统</p>\n</li>\n<li><p>路由机制</p>\n</li>\n<li><p>状态管理</p>\n</li>\n<li><p>安装方式</p>\n<ul>\n<li>直接引用vue.js</li>\n<li>利用npm安装</li>\n<li>利用cmd安装等</li>\n</ul>\n</li>\n<li><p>版本区别</p>\n<ul>\n<li><p>开发版本</p>\n<ul>\n<li><blockquote>\n<p>项目开发阶段使用，没有代码压缩，并且有错误提</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>生产版本</p>\n<ul>\n<li><blockquote>\n<p>正式版本，代码压缩，没有错误提示</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="vue-js-">VUE.JS的基本语法</h2>\n<h3 id="-">基本操作</h3>\n<pre><code class="language-html">&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;\n&lt;div id=&quot;app&quot;&gt;\n    {{message}},{{test}}\n&lt;/div&gt;\n&lt;div v-text=&quot;message&quot;&gt;\n\n&lt;/div&gt;\n&lt;script&gt;\n    //1.vue主要我们完成vm层开发\n    //2.el属性表示vue要控制的区域\n    //3.data数据对象，定义声明式的数据\n    //4.通过插值表达式{{js的执行环境}}，渲染页面。表达式中可以进行基本的js运算，可以写运算符，一些语法，但不能写语句。\n    //5.在vue中，基于面向对象的开发new Vue（）方式，在一个类中写了一个{}，这个叫配置参数。根据参数的不同，可以创建不同形态的对象。\n    //6.vm对象下，$ 和 _一般表示这些属性都是vue自带的属性和方法。\n    //7.vm.$data中的数据，挂载到了vm对象下，方便用户操作和内部使用。\n    //8.v-* :vue自带的指令（vue帮我实现了一些功能）\n    var vm = new VUE({\n        el:&#39;#app&#39;,\n        data:{\n            message:&#39;hellow vue&#39;,\n            test:&#39;我是一个测试文本&#39;\n        }\n    })\n&lt;/script&gt;</code></pre>\n<h3 id="vue-">VUE常用指令</h3>\n<ul>\n<li><p><code>v-*</code>  vue.js自带13种指令</p>\n</li>\n<li><p><code>v-text</code>  渲染数据。v-text=&quot;变量/&#39;字符串&#39;&quot;。直接渲染在标签内，作为标签的属性。不会解析html语法</p>\n</li>\n<li><p><code>v-html</code>  渲染数据。会自动解析html语法</p>\n<ul>\n<li>不建议在data数据中写html标签，这样解析html标签，不安全，可能会被攻击(XSS)，(CSRF)</li>\n</ul>\n</li>\n<li><p><code>v-once</code>  一次性插值。给标签添加v-once属性。关闭标签的响应式。可以在特定情况下提升性能</p>\n</li>\n<li><p><code>v-bind</code>  操作HTML属性。是vue中使用最为频繁的指令之一；可简写为:</p>\n<ul>\n<li><pre><code class="language-html">&lt;div v-bind:title=&quot;variable&quot;&gt;\n    用vue来管理title属性，这样title中的值就是一个变量（在data中赋值variable:&#39;这是用来显示的标题&#39;）\n&lt;/div&gt;</code></pre>\n</li>\n<li><pre><code class="language-html">&lt;div :title=&quot;true? &#39;box&#39; : &#39;box2&#39;&quot;&gt;\n    简写，省略了v-bind，只保留了:\n&lt;/div&gt;</code></pre>\n</li>\n</ul>\n</li>\n<li><p><code>v-on</code>  给html添加事件。同样是vue使用最为频繁的指令之一；可简写为@</p>\n<ul>\n<li><pre><code class="language-html">&lt;div v-on:click=&quot;show&quot; id=&quot;event&quot;&gt;\n\n&lt;/div&gt;\n&lt;div @click.stop=&quot;show&quot; id=&quot;event&quot;&gt;\n\n&lt;/div&gt;\n&lt;script&gt;\n    //vm对象中有一个methods用来写事件的方法\n    //methods属性中的方法同样会被自动挂载到vm对象中。也就是vm.methods.show === vm.show\n    var vm = new Vue({\n        el:&#39;event&#39;,\n        data:{\n\n        },\n        methods:{\n            show(){\n                console.log(123)\n            }\n        }\n    })\n&lt;/script&gt;</code></pre>\n</li>\n<li><p><code>.stop</code> - 调用 <code>event.stopPropagation()</code>。</p>\n</li>\n<li><p><code>.prevent</code> - 调用 <code>event.preventDefault()</code>。</p>\n</li>\n<li><p><code>.capture</code> - 添加事件侦听器时使用 capture 模式。</p>\n<ul>\n<li>触发捕获阶段。不触发冒泡阶段</li>\n</ul>\n</li>\n<li><p><code>.self</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</p>\n<ul>\n<li>停止事件流动。事件只在本身触发</li>\n</ul>\n</li>\n<li><p><code>.{keyCode | keyAlias}</code> - 只当事件是从特定键触发时才触发回调。</p>\n<ul>\n<li><code>&lt;div @keydown.13&gt;&lt;/div&gt;</code></li>\n</ul>\n</li>\n<li><p><code>.native</code> - 监听组件根元素的原生事件。</p>\n<ul>\n<li>组件标签上的事件都是自定义事件，需要用$emit触发</li>\n<li>可以通过加<code>.native</code>  ,使组件的自定义事件变成原生事件</li>\n</ul>\n</li>\n<li><p><code>.once</code> - 只触发一次回调。</p>\n</li>\n<li><p><code>.left</code> - (2.2.0) 只当点击鼠标左键时触发。</p>\n<ul>\n<li><blockquote>\n<p>还有 .enter .ctrl .alt .meta .space等等</p>\n<p>还可以在.enter.exact达到精确匹配的目的，（同时按下其他键无效）</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><code>.right</code> - (2.2.0) 只当点击鼠标右键时触发。</p>\n</li>\n<li><p><code>.middle</code> - (2.2.0) 只当点击鼠标中键时触发。</p>\n</li>\n<li><p><code>.passive</code> - (2.3.0) 以 <code>{ passive: true }</code> 模式添加侦听器</p>\n<ul>\n<li>提升移动端性能</li>\n<li>跟<code>.prevent</code> 完全相反的操作</li>\n<li>提前告诉浏览器我不去阻止默认行为，用来提升性能</li>\n</ul>\n</li>\n<li><p>对象语法（2.4.0+）</p>\n<ul>\n<li><pre><code class="language-html">&lt;button v-on=&quot;{ mousedown: doThis, mouseup: doThat }&quot;&gt;&lt;/button&gt;</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>v-show</code>  条件渲染</p>\n<ul>\n<li>与<code>v-if</code> 的区别是<code>v-show</code>是操作css属性display</li>\n<li><code>&lt;div v-show=&quot;true&quot;&gt;&lt;/div&gt;</code></li>\n<li>根据表达式的真假值，切换元素的display css属性</li>\n<li>当条件发生变化时该指令触发过度效果</li>\n<li>适用于频繁的显示隐藏</li>\n</ul>\n</li>\n<li><p><code>v-if</code>  条件渲染</p>\n<ul>\n<li>对html进行显示隐藏，对DOM进行原生的<em>appendchild</em>和<em>removechild</em></li>\n<li><code>&lt;div v-if=&quot;Math.rondam() &gt; 0.5&quot;&gt;&lt;/div&gt;</code></li>\n<li>根据表达式的值的真假条件渲染元素。在切换时，元素及它的数据绑定/组件被销毁并重建。</li>\n<li>但如果切换时，两个标签完全一样，vue会对便签进行复用（如<code>&lt;input&gt;</code>）</li>\n<li>如果元素时<code>&lt;template&gt;</code> ,将提出它的内容作为条件块。<code>&lt;template&gt;</code>标签不会出现在DOM节点上。是vue自定义的标签，用来充当临时容器。</li>\n<li>当条件发生变化时，该指令触发过渡效果</li>\n<li>适用于不频繁的显示隐藏</li>\n</ul>\n</li>\n<li><p><code>v-else-if</code>  条件渲染</p>\n<ul>\n<li><code>&lt;div v-else-if=&quot;Math.rondam() = 0.5&quot;&gt;&lt;/div&gt;</code></li>\n<li>前一个兄弟元素必须有<code>v-if</code>或<code>v-else-if</code>。</li>\n</ul>\n</li>\n<li><p><code>v-else</code>   条件渲染</p>\n<ul>\n<li><code>&lt;div v-else&gt;&lt;/div&gt;</code></li>\n<li>前一个兄弟元素必须有<code>v-if</code>或<code>v-else-if</code>。</li>\n</ul>\n</li>\n<li><p><code>v-for</code>   列表渲染</p>\n<ul>\n<li><p>基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 <code>alias in expression</code> ，为当前遍历的元素提供别名： </p>\n</li>\n<li><pre><code class="language-html">&lt;div v-for=&quot;item in items&quot;&gt;\n  {{ item }}\n&lt;/div&gt;\n&lt;script&gt;\n    var vm = new Vue({\n        el:&#39;#app&#39;,\n        data:{\n           items:[111,222,333] \n        }\n    })\n&lt;/script&gt;</code></pre>\n</li>\n<li><p>另外也可以为数组索引指定别名 (或者用于对象的键)： </p>\n</li>\n<li><pre><code class="language-html">&lt;div v-for=&quot;(item, index) in items&quot;&gt;{{item}},{{index}}&lt;/div&gt;&lt;!--返回数组的值，和索引-&gt;\n&lt;div v-for=&quot;(val, key) in object&quot;&gt;&lt;/div&gt;&lt;!--返回对象的值，和属性-&gt;\n&lt;div v-for=&quot;(val, key, index) in object&quot;&gt;&lt;/div&gt;&lt;!--返回对象的值，和属性，索引&gt;</code></pre>\n</li>\n<li><p>默认行为试着不改变整体，而是替换元素。迫使其重新排序的元素，你需要提供一个 <code>key</code> 的特殊属性： </p>\n</li>\n<li><pre><code class="language-html">&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;\n  {{ item.text }}\n&lt;/div&gt;\n//key属性的作用区分不用的节点。否则vue会对节点进行复用</code></pre>\n</li>\n<li><p><em>item in items</em>可以用 <em>item of items</em> 代替 因为es6 有一个for of循环。趋势所使</p>\n<ul>\n<li><pre><code class="language-javascript">var arr = [1,2,3,4,5]\nfor(let v of arr){\n    console.log(v)\n}\n//for of 方法不支持对象的遍历，我们可以通过下面的方法解决这个问题\nObject.keys(obj);//把一个对象的属性转化成数组\nObject.values(obj);//把一个对象的值转化成数组\nObject.entries(obj);//把一个对象的属性和值转化成二维数组</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>v-model</code>  表单控件绑定</p>\n<ul>\n<li>限制<ul>\n<li><code>&lt;input&gt;</code></li>\n<li><code>&lt;select&gt;</code></li>\n<li><code>&lt;textarea&gt;</code></li>\n<li><code>&lt;components&gt;</code></li>\n</ul>\n</li>\n<li><code>&lt;input v-model=&quot;variable&quot; /&gt;</code></li>\n<li>修饰符<ul>\n<li><code>.lazy</code> - 取代 <code>input</code> 监听 <code>change</code> 事件<ul>\n<li>当光标移开输入框才能触发响应式</li>\n</ul>\n</li>\n<li><code>.number</code> - 输入字符串转为数字<ul>\n<li>输入框默认会把输入内容转成字符串</li>\n<li>表单返回值返回数字</li>\n</ul>\n</li>\n<li><code>.trim</code> - 输入首尾空格过滤<ul>\n<li>页面上看不到效果</li>\n<li>会在表单的返回值上表示</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>在表单控件或者组件上创建双向绑定。 在通过watch等方法实现实时更新</li>\n<li>如果<code>v-model=&quot;true&quot;</code>会默认选中单选框或多选框</li>\n</ul>\n</li>\n<li><p><code>v-pre</code>  跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache <a href="%E6%98%AF%E4%B8%80%E7%A7%8D%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E">^mustache</a>标签。跳过大量没有指令的节点会加快编译。</p>\n<ul>\n<li><code>&lt;div v-pre&gt;&lt;/div&gt;</code> </li>\n</ul>\n</li>\n<li><p><code>v-cloak</code>  隐藏渲染</p>\n<ul>\n<li>这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 <code>[v-cloak] { display: none }</code> 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。 </li>\n<li><code>&lt;div v-cloak&gt;&lt;/div&gt;</code></li>\n</ul>\n</li>\n</ul>\n<h3 id="computed-">Computed ：计算属性（对象）</h3>\n<ul>\n<li>computed对象里都是方法，但用的时候当属性来用。不需要调用</li>\n<li>同时我们也可以使用methods里面定义的函数，但这个函数必须调用，否则会在页面上直接显示代码</li>\n</ul>\n<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;\n    {{messageFn}}\n    {{messageMe()}}\n&lt;/div&gt;\n&lt;script&gt;\n    var vm = new Vue({\n        el:&#39;#app&#39;,\n        data:{\n\n        },\n        methods:{\n            messageMe(){\n                return &#39;hello world&#39;\n            }  \n        },\n        computed:{\n            messageFn(){\n               return &#39;hello world&#39;\n            }\n        }\n    })\n&lt;/script&gt;</code></pre>\n<ul>\n<li><p>优点</p>\n<ul>\n<li><p>跟插值表达式中写语法相比，要更简洁，方便。</p>\n</li>\n<li><p>跟methods相比，计算属性是基于他们的依赖进行缓存的，计算属性只有在相关依赖进行改变时，才会发生改变。所以要比methods跟快一些</p>\n</li>\n<li><p>所以我们不能直接更改computed定义的方法。如上面的例子vm.messageFn = xxx会报错。当时我们可以通过将computed定义的方法改成对象的写法来更改</p>\n<ul>\n<li><pre><code class="language-javascript">computed:{\n    messageFn:{\n        set(newVal){\n            this.message = newVal\n        },\n        get(){\n            return this.message       \n        }\n    }\n}</code></pre>\n</li>\n</ul>\n</li>\n<li><p>计算属性跟watch相比，更加简单易用</p>\n</li>\n<li><p>计算属性不适合异步数据操作</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="watch-">Watch 监听数据变化的属性（对象）</h3>\n<ul>\n<li>一般适用于异步的数据操作</li>\n</ul>\n<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;\n    {{messageFn}}\n    {{messageMe()}}\n&lt;/div&gt;\n&lt;script&gt;\n    var vm = new Vue({\n        el:&#39;#app&#39;,\n        data:{\n            message:&#39;hello world&#39;\n        },\n        methods:{\n            messageMe(){\n                return this.message\n            }  \n        },\n        computed:{\n            messageFn(){\n               return this.message\n            }\n        },\n        watch:{\n            message(newVal,oldVal){\n                //当message属性发生变化时，触发\n                console.log(&#39;新值&#39;,newVal);\n                console.log(&#39;旧值&#39;,oldVal)\n            }\n        }\n    })\n&lt;/script&gt;</code></pre>\n<h3 id="class-style-">Class 与 Style的绑定</h3>\n<ul>\n<li><p><em>class</em> 的对象语法</p>\n<ul>\n<li><blockquote>\n<p><code>&lt;div :class=&quot;{{box:true , white: false}}&quot;&gt;&lt;/div&gt;</code></p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><em>class</em> 的数组的语法</p>\n<ul>\n<li><blockquote>\n<div :class="[box,box2,box3]"></div>\n\n<p>data{</p>\n<p>​    box:{box:ture},</p>\n<p>​    box2:{box2:ture},</p>\n<p>​    box3:{box3.true}</p>\n<p>}</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><em>style</em> 的对象语法</p>\n<ul>\n<li><blockquote>\n<p><code>&lt;div :style=&quot;{background:&#39;red&#39;,height:&#39;100px&#39;,height:&#39;100px&#39;}&quot;</code></p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><em>style</em> 的数组语法同<em>class</em> 的数组语法</p>\n<ul>\n<li><blockquote>\n<p>此处不枚举</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="vue-js-">Vue.js 的数组方法</h3>\n<ul>\n<li><p>变异的数组方法，具有响应式（已经不是原生的啦）</p>\n<ul>\n<li><code>push()</code></li>\n<li><code>unshift()</code></li>\n<li><code>pop()</code></li>\n<li><code>shift()</code></li>\n<li><code>splice()</code></li>\n<li><code>reverse()</code></li>\n<li><code>sort()</code></li>\n</ul>\n</li>\n<li><p>其他的数组方法均没有响应式。可以通过查看构造函数是否带有_<em>Observer_</em>进行判断</p>\n<ul>\n<li><p>可以通过重新赋值，来实现没有响应式的数组方法，进行响应式</p>\n</li>\n<li><p>复习数组的filter(),map(),find(),findIndex()方法</p>\n<ul>\n<li><pre><code class="language-javascript">filter(callback)//过滤数组，值为真留下来，值为假过滤掉。不能改变原数组，重新生成数组\nvar arr = [1,2,3,4,5,6]\narr = arr.filter((val)=&gt;{\n    return val%2\n})\n//则得到的数组是我们过滤掉偶数的新数组</code></pre>\n</li>\n<li><pre><code class="language-javascript">map(callback)//重新映射数组，对数组的每一项进行重新的返回。不能改变原数组，重新生成数组\nvar arr = [1,2,3,4,5,6]\narr = arr.map((val)=&gt;{\n    return val*val\n})\n//得到一个新数组，每个值为旧数组的每个值得平方</code></pre>\n</li>\n<li><pre><code class="language-javascript">find(callback)//返回数组中，符合条件的第一个元素</code></pre>\n</li>\n<li><pre><code class="language-javascript">findIndex(callback)//返回数组中，符合条件的第一个元素的索引</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n'},"CO/4":function(n,e){},DCME:function(n,e){n.exports="data:image/png;base64,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"},DVFD:function(n,e){},"F+8y":function(n,e,t){"use strict";var l={render:function(){var n=this.$createElement;return(this._self._c||n)("div",{attrs:{id:"myjs"}})},staticRenderFns:[]};e.a=l},FW3m:function(n,e){n.exports='<h1 id="vue-js-third-days">Vue.js Third days</h1>\n<h2 id="-">单文件组件</h2>\n<ul>\n<li>把每一个组件单独的形成一个独立的文件，文件后缀为<code>.vue</code><ul>\n<li><code>xxx.vue</code>包含：跟当前组件相关的CSS,JS,HTML</li>\n<li>通过<code>webpack</code>打包工具把<code>xxx.vue</code>文件转化成<code>js</code>文件</li>\n</ul>\n</li>\n</ul>\n<h3 id="webpack-">webpack基本用法</h3>\n<ul>\n<li>安装<strong>webpack</strong> 打包工具(用于生产环境的打包)<ul>\n<li>是一个现代js应用程序的静态模块打包器<ul>\n<li>把浏览器不识别的文件打包成浏览器识别的文件</li>\n<li>对前端代码进行模块化开发，在webpack世界了，一切都是模块（可以遵循commonjs规范）<ul>\n<li>前端模块化开发的框架，（seajs requirejs babaljs webpack 等）</li>\n</ul>\n</li>\n<li>对项目进行一些工程化操作（自动合并文件，压缩文件，开启web服务器）</li>\n<li>使用vue开发项目时，vue已经提供了vue的脚手架（搭建了webpack关联vue的运行环境）</li>\n</ul>\n</li>\n<li>使用步骤<ol>\n<li>全局安装<code>npm install webpack webpack-cli -g</code></li>\n<li>创建一个项目，初始化环境<code>npm init</code>自动创建一个<strong>package.json</strong>文件</li>\n<li>局部安装<code>npm install webpack webpack-cli -D</code><ol>\n<li><code>-D  等同与  --save-dev</code></li>\n</ol>\n</li>\n<li>配置<code>webpack.config.js</code><ol>\n<li>入口函数<code>entry:__dirname+&#39;/app.js&#39;</code></li>\n<li>输出文件<code>output:{path:__dirname+&#39;/build&#39;,filename:&#39;bundle.js&#39;}</code></li>\n<li>加载器<code>loaders</code>把浏览器不认识的文件，转化浏览器认识的文件</li>\n<li>插件<code>plugins</code></li>\n<li>格式<code>mode:development</code>设置为开发者模式<code>mode:production</code>设置为生产模式</li>\n<li>映射源码<code>devtool:eval-source-map</code>调试错误很方便。</li>\n</ol>\n</li>\n<li>直接使用就好啦<ol>\n<li>可以通过<code>webpack -w</code>来实时监听文件的改变，就不需要每一次都重新打包一次了</li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>安装<strong>webpack-dev-server</strong>服务器(主要用于开发环境)</p>\n<ul>\n<li><p>依赖<code>webpack打包工具</code></p>\n</li>\n<li><p>全局安装<code>npm install webpack-dev-server -g</code></p>\n</li>\n<li><p>创建一个项目，初始化环境<code>npm init</code>自动创建一个<strong>package.json</strong>文件</p>\n</li>\n<li><p>局部安装<code>npm install webpack-dev-server -D</code></p>\n</li>\n<li><p>同样配置<code>webpack.config.js</code>文件</p>\n<ul>\n<li><blockquote>\n<p>devServer:{</p>\n<p>​    open:true自动打开浏览器</p>\n<p>​    port:3000监听端口号</p>\n<p>}</p>\n</blockquote>\n</li>\n<li><p>会自动把合并的文件生成到内存中，运行速度很快</p>\n</li>\n</ul>\n</li>\n<li><p>在当前环境下执行<code>webpack-dev-server</code></p>\n<ul>\n<li><p>会自动生成<code>bundle.js</code>文件在内存中。我们可以在<code>index.html</code>文件中引用</p>\n</li>\n<li><p>会自动寻找当前文件夹下的<code>index.html</code>并打开。否则在浏览器返回文件夹目录</p>\n</li>\n<li><p>自带热更新功能，修改了代码，自动重启服务器，刷新浏览器</p>\n</li>\n</ul>\n</li>\n<li><p>根据返回的端口号。打开浏览器</p>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><strong>webpack</strong> 的插件(html-webpack-plugin)</p>\n<ul>\n<li><p>下载插件npm install xxx -D</p>\n</li>\n<li><p>在<code>webpack.config.js</code>文件中引用这个模块<code>require(&#39;xxx&#39;)</code></p>\n</li>\n<li><p>在<code>webpack.config.js</code>文件中配置这个模块</p>\n<ul>\n<li><blockquote>\n<p>plugins:[</p>\n<p>​    new HtmlWebpackPlugin({</p>\n<p>​        template:__dirname+&#39;/src/index.html&#39;</p>\n<p>​    })</p>\n<p>]</p>\n<p>选择src文件夹下的index.html作为入口模板</p>\n<p>这个模块会把我们指定的html文件加载到缓存中，在缓存中加载缓存中的js文件，且不需要在HTML文件中指定路径</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><strong>webpack</strong> 的<code>loaders</code></p>\n<ul>\n<li><p>下载安装依赖的loaders模块</p>\n<ul>\n<li>例如<code>cnpm install --save-dev style-loader css-loader</code></li>\n</ul>\n</li>\n<li><p>配置<code>webpack.config.js</code></p>\n<ul>\n<li><blockquote>\n<p>module:{</p>\n<p>​    rules:[</p>\n<p>​        {</p>\n<p>​            test:/\\.css$/,</p>\n<p>​            use:[</p>\n<p>​                 {</p>\n<p>​                    loader: &#39;url-loader&#39;,</p>\n<p>​                    options:{</p>\n<p>​                                name:&#39;[name].[ext]&#39;</p>\n<p>​                            }    </p>\n<p>​                }                        </p>\n<p>​                ]    </p>\n<p>​        },</p>\n<p>​    ]</p>\n<p>}</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="vue-js-">Vue.js 的脚手架</h3>\n<ul>\n<li>全局安装vue命令行<code>npm install -g vue-cli</code></li>\n<li>局部安装<code>vue init webpack-simple my-project</code>安装学习版本的vue脚手架<ul>\n<li><code>my-project</code>可以自定义，使我们项目的名字</li>\n</ul>\n</li>\n<li>局部安装<code>vue init webpack my-project</code>安装实战版本的vue脚手架<ul>\n<li>安装过程中我们可以配置<ul>\n<li>项目名</li>\n<li>描述</li>\n<li>作者</li>\n<li>是否进行运行+编译 或者只是运行</li>\n<li>是否使用路由</li>\n<li>是否使用ESlint语法使用规则检测工具</li>\n<li>是否使用测试工具（默认摩卡）</li>\n<li>是否使用e2e测试工具</li>\n<li>是否使用npm或yarn作为操作工具</li>\n</ul>\n</li>\n<li><code>assets</code>文件夹下的文件会自动生成模块</li>\n<li><code>build</code>文件夹为webpack的配置文件夹</li>\n<li><code>config</code>为配置文件</li>\n<li><code>postcssrc</code>后处理css（可以自行了解一下）</li>\n<li><code>static放置</code>静态文件（不想被模块化的文件）</li>\n</ul>\n</li>\n</ul>\n<h3 id="es6-">ES6 的模块化开发</h3>\n<ul>\n<li><blockquote>\n<p>引入模块</p>\n<p>import variable form &#39;./xx.js&#39;</p>\n<p>import {名字一致,yes} form &#39;./xx.js&#39;</p>\n<p>引入css文件</p>\n<p>import &#39;xxx.css&#39;</p>\n<p>导出模块</p>\n<p>export default variable</p>\n<p>export {</p>\n<p>​    xx as 名字一致,</p>\n<p>​    mm as yes</p>\n<p>}</p>\n</blockquote>\n</li>\n</ul>\n<h3 id="-">单文件组件</h3>\n<ul>\n<li><p>结构</p>\n<pre><code class="language-html">&lt;tempalte&gt;&lt;/template&gt;\n\n&lt;script&gt;\n\n    export default {\n\n​    name:&#39;作为每个vue文件的标识ID&#39;\n\n }\n\n &lt;/script&gt;\n\n &lt;style scoped&gt;&lt;/style&gt;\n\n  如果想使用sass，需自己配置sass-loader/style-loader/css-loader/node-sass，然后&lt;style lang=&quot;scss&quot;&gt;</code></pre>\n</li>\n<li><p><code>static</code>文件夹</p>\n<ul>\n<li>该文件夹下的文件做静态资源，需要通过<code>href/src</code>引入‘/static/xxx.xx’</li>\n</ul>\n</li>\n<li><p><code>assets</code> 文件夹</p>\n<ul>\n<li>该文件夹下的文件做模块资源，需通过<code>import &#39;@/assets/xx/xxx.xx&#39;</code>方法引入</li>\n<li><code>@</code>在webpack中做别名指<code>src</code></li>\n</ul>\n</li>\n</ul>\n'},IZM8:function(n,e){},J55r:function(n,e){},LGEB:function(n,e){},Li1M:function(n,e){},NHnr:function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var l=t("IvJb"),i={render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{attrs:{id:"app"}},[e("router-view")],1)},staticRenderFns:[]};var o=t("C7Lr")({name:"App",components:{}},i,!1,function(n){t("OWNv")},null,null).exports,s=t("zO6J"),a={render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{attrs:{id:"worldofwar"}},[t("div",{staticClass:"all"},[t("div",{on:{click:n.myhtml}},[n._v("HTML")]),n._v(" "),t("div",{on:{click:n.mycss}},[n._v("CSS")]),n._v(" "),t("div",{on:{click:n.myjs}},[n._v("Javascript")]),n._v(" "),t("div",[n._v("TODO")]),n._v(" "),t("div",[n._v("TODO")]),n._v(" "),t("div",[n._v("TODO")]),n._v(" "),t("div",{on:{click:n.mydemo}},[n._v("Demo")]),n._v(" "),t("div",{on:{click:n.myblogs}},[n._v("Blogs")]),n._v(" "),t("div",[n._v("TODO")]),n._v(" "),t("div",{on:{click:n.profile}},[n._v("profile")]),n._v(" "),t("div",{on:{click:n.myvue}},[n._v("Vue.js")]),n._v(" "),t("div",[n._v("React")]),n._v(" "),t("div",[n._v("Angular")])]),n._v(" "),t("p",{staticClass:"about"},[n._v("\n\t  \tClick on the fan to see my profile\n\t")])])},staticRenderFns:[]};var u=t("C7Lr")({name:"worldofwar",methods:{myhtml:function(){this.$router.push("/html")},mycss:function(){this.$router.push("/css")},myjs:function(){this.$router.push("/javascript")},profile:function(){this.$router.push("/profile")},mydemo:function(){this.$router.push("/demo")},myblogs:function(){this.$router.push("/blogs")},myvue:function(){this.$router.push("/myvue")}}},a,!1,function(n){t("J55r")},"data-v-cc1a4f56",null).exports,d=(t("1P4l"),t("A28e")),c=t.n(d),r={name:"myhtml",data:function(){return{vueOne:c.a}},components:{}},p={render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{attrs:{id:"myhtml"}},[n._m(0),n._v(" "),t("article",{staticClass:"w"},[t("h2",[n._v("初识HTML标记语言")]),n._v(" "),n._m(1),n._v(" "),t("div",{directives:[{name:"highlight",rawName:"v-highlight"}],staticClass:"md",domProps:{innerHTML:n._s(n.vueOne)}})])])},staticRenderFns:[function(){var n=this.$createElement,e=this._self._c||n;return e("header",[e("h1",[this._v("HTML")])])},function(){var n=this.$createElement,e=this._self._c||n;return e("h3",[this._v("作者:"),e("span",[this._v("upeartaker")])])}]};var v=t("C7Lr")(r,p,!1,function(n){t("yE95")},null,null).exports,g={render:function(){this.$createElement;this._self._c;return this._m(0)},staticRenderFns:[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{attrs:{id:"mycss"}},[t("header",[t("h1",[n._v("CSS")])]),n._v(" "),t("article",{staticClass:"w"},[t("h2",[n._v("初识CSS层叠样式表")]),n._v(" "),t("h3",[n._v("作者:"),t("span",[n._v("upeartaker")])]),n._v(" "),t("p",[n._v("\n\t\t\tCSS，全称Cascading Style Sheets，层叠样式表\n\t\t")])])])}]};var m=t("C7Lr")({name:"mycss"},g,!1,function(n){t("Twv2")},"data-v-d4df7618",null).exports,h=t("OVXi"),f={render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"layout"},[t("Layout",[t("Header",[t("Menu",{attrs:{mode:"horizontal",theme:"dark","active-name":"1"}},[t("div",{staticClass:"layout-logo"}),n._v(" "),t("div",{staticClass:"layout-nav"},[t("MenuItem",{attrs:{name:"1"}},[t("Icon",{attrs:{type:"ios-navigate"}}),n._v("\n                            Item 1\n                        ")],1),n._v(" "),t("MenuItem",{attrs:{name:"2"}},[t("Icon",{attrs:{type:"ios-keypad"}}),n._v("\n                            Item 2\n                        ")],1),n._v(" "),t("MenuItem",{attrs:{name:"3"}},[t("Icon",{attrs:{type:"ios-analytics"}}),n._v("\n                            Item 3\n                        ")],1),n._v(" "),t("MenuItem",{attrs:{name:"4"}},[t("Icon",{attrs:{type:"ios-paper"}}),n._v("\n                            Item 4\n                        ")],1)],1)])],1),n._v(" "),t("Layout",{style:{padding:"0 50px"}},[t("Breadcrumb",{style:{margin:"16px 0"}},[t("BreadcrumbItem",[n._v("Home")]),n._v(" "),t("BreadcrumbItem",[n._v("Components")]),n._v(" "),t("BreadcrumbItem",[n._v("Layout")])],1),n._v(" "),t("Content",{style:{padding:"24px 0",minHeight:"280px",background:"#fff"}},[t("Layout",[t("Sider",{style:{background:"#fff"},attrs:{"hide-trigger":""}},[t("Menu",{attrs:{"active-name":"1-2",theme:"light",width:"auto","open-names":["1"]}},[t("Submenu",{attrs:{name:"1"}},[t("template",{slot:"title"},[t("Icon",{attrs:{type:"ios-navigate"}}),n._v("\n                                        Item 1\n                                    ")],1),n._v(" "),t("MenuItem",{attrs:{name:"1-1"}},[n._v("Option 1")]),n._v(" "),t("MenuItem",{attrs:{name:"1-2"}},[n._v("Option 2")]),n._v(" "),t("MenuItem",{attrs:{name:"1-3"}},[n._v("Option 3")])],2),n._v(" "),t("Submenu",{attrs:{name:"2"}},[t("template",{slot:"title"},[t("Icon",{attrs:{type:"ios-keypad"}}),n._v("\n                                        Item 2\n                                    ")],1),n._v(" "),t("MenuItem",{attrs:{name:"2-1"}},[n._v("Option 1")]),n._v(" "),t("MenuItem",{attrs:{name:"2-2"}},[n._v("Option 2")])],2),n._v(" "),t("Submenu",{attrs:{name:"3"}},[t("template",{slot:"title"},[t("Icon",{attrs:{type:"ios-analytics"}}),n._v("\n                                        Item 3\n                                    ")],1),n._v(" "),t("MenuItem",{attrs:{name:"3-1"}},[n._v("Option 1")]),n._v(" "),t("MenuItem",{attrs:{name:"3-2"}},[n._v("Option 2")])],2)],1)],1),n._v(" "),t("Content",{style:{padding:"24px",minHeight:"280px",background:"#fff"}},[n._v("\n                            Content\n                        ")])],1)],1)],1),n._v(" "),t("Footer",{staticClass:"layout-footer-center"},[n._v("2011-2016 © TalkingData")])],1)],1)},staticRenderFns:[]};var q=t("C7Lr")({name:"profile"},f,!1,function(n){t("Li1M")},"data-v-4a01226a",null).exports,b={render:function(){var n=this.$createElement;return(this._self._c||n)("router-view")},staticRenderFns:[]};var x=t("C7Lr")({name:"mydemo"},b,!1,function(n){t("901n")},"data-v-67095beb",null).exports,y={render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"layout",attrs:{id:"myheader"}},[t("Layout",[t("Header",[t("Menu",{attrs:{mode:"horizontal",theme:"dark","active-name":"1"}},[t("MenuItem",{attrs:{name:"1"}},[t("Icon",{attrs:{type:"ios-paper"}}),n._v("\n\t\t            内容管理\n\t\t        ")],1),n._v(" "),t("MenuItem",{attrs:{name:"2"}},[t("Icon",{attrs:{type:"ios-people"}}),n._v("\n\t\t            用户管理\n\t\t        ")],1),n._v(" "),t("Submenu",{attrs:{name:"3"}},[t("template",{slot:"title"},[t("Icon",{attrs:{type:"ios-stats"}}),n._v("\n\t\t                统计分析\n\t\t            ")],1),n._v(" "),t("MenuGroup",{attrs:{title:"使用"}},[t("MenuItem",{attrs:{name:"3-1"}},[n._v("新增和启动")]),n._v(" "),t("MenuItem",{attrs:{name:"3-2"}},[n._v("活跃分析")]),n._v(" "),t("MenuItem",{attrs:{name:"3-3"}},[n._v("时段分析")])],1),n._v(" "),t("MenuGroup",{attrs:{title:"留存"}},[t("MenuItem",{attrs:{name:"3-4"}},[n._v("用户留存")]),n._v(" "),t("MenuItem",{attrs:{name:"3-5"}},[n._v("流失用户")])],1)],2),n._v(" "),t("MenuItem",{attrs:{name:"4"}},[t("Icon",{attrs:{type:"ios-construct"}}),n._v("\n\t\t            综合设置\n\t\t        ")],1)],1)],1)],1)],1)},staticRenderFns:[]};var w={name:"myblogs",components:{blogs_header:t("C7Lr")({name:"blogs_header"},y,!1,function(n){t("LGEB")},"data-v-fea1adf0",null).exports}},k={render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{attrs:{id:"myblogs"}},[e("blogs_header")],1)},staticRenderFns:[]};var j=t("C7Lr")(w,k,!1,function(n){t("PALI")},"data-v-f8c2c878",null).exports,C={name:"snake",data:function(){return{show:!0,id:"",createSnake:null,snakeBody:[{x:0,y:0},{x:10,y:0},{x:20,y:0},{x:30,y:0},{x:40,y:0}],moveSnake:null,directX:0,directY:1,createFood:null,clearSnake:null,foodX:Math.floor(500*Math.random()),foodY:Math.floor(500*Math.random()),eatFood:null,dieSnake:null,score:null}},mounted:function(){var n=this.$refs.cans.getContext("2d");this.createSnake=function(){n.clearRect(0,0,this.$refs.cans.width,this.$refs.cans.height);for(var e=0;e<this.snakeBody.length;e++)n.save(),n.beginPath(),n.fillRect(this.snakeBody[e].x,this.snakeBody[e].y,10,10),n.closePath(),n.restore()},this.moveSnake=function(){n.clearRect(0,0,this.$refs.cans.width,this.$refs.cans.height),this.snakeBody[0].x+=10*this.directX,this.snakeBody[0].y+=10*this.directY;for(var e=this.snakeBody.length-1;e>0;e--)this.snakeBody[e].x=this.snakeBody[e-1].x,this.snakeBody[e].y=this.snakeBody[e-1].y;this.createSnake(),this.createFood(),this.eatFood(),this.dieSnake()},this.createFood=function(){n.save(),n.beginPath(),n.fillStyle="red",n.fillRect(this.foodX,this.foodY,10,10),n.closePath(),n.restore()},this.eatFood=function(){var n=this.snakeBody[0].x,e=this.snakeBody[0].y;if(this.foodY<e+10&&this.foodY+10>e&&this.foodX<n+10&&this.foodX+10>n){this.foodX=Math.floor(500*Math.random()),this.foodY=Math.floor(500*Math.random());var t=this.snakeBody[this.snakeBody.length-1],l=this.snakeBody[this.snakeBody.length-2],i=t.x-l.x,o=t.y-l.y,s={x:t.x+i,y:t.y+o};this.snakeBody.push(s),this.score()}},this.dieSnake=function(){(this.snakeBody[0].x>this.$refs.cans.width||this.snakeBody[0].x<0||this.snakeBody[0].y>this.$refs.cans.height||this.snakeBody[0].y<0)&&(clearInterval(this.id),alert("is Died"))},this.score=function(){this.$refs.score.innerHTML++}},methods:{handleMove:function(n){87===n.keyCode&&(this.directX=0,this.directY=-1),83===n.keyCode&&(this.directX=0,this.directY=1),65===n.keyCode&&(this.directX=-1,this.directY=0),68===n.keyCode&&(this.directX=1,this.directY=0)},handleShow:function(n){var e=this;this.show&&(this.$refs.music.play(),this.createSnake(),this.createFood(),this.show=!1,this.id=setInterval(function(){e.moveSnake()},200)),document.styleSheets[0].addRule("#snake::after","display: none")}}},V={render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{attrs:{id:"snake",tabindex:"1"},on:{click:n.handleShow,keydown:n.handleMove}},[t("div",{staticClass:"score"},[t("p",[n._v("计分板")]),n._v(" "),t("span",{ref:"score"},[n._v("0")])]),n._v(" "),t("canvas",{ref:"cans",attrs:{width:"500",height:"500"}}),n._v(" "),t("audio",{ref:"music",attrs:{src:"/static/music.mp3",loop:""}},[n._v("您的浏览器不支持")])])},staticRenderFns:[]};var M=t("C7Lr")(C,V,!1,function(n){t("hvcD")},"data-v-81dcf9be",null).exports,L={render:function(){var n=this.$createElement;return(this._self._c||n)("div",{attrs:{id:"brick"}},[this._v("brick")])},staticRenderFns:[]};var S=t("C7Lr")({name:"brick"},L,!1,function(n){t("UZOl")},"data-v-9f7b58c0",null).exports,O={render:function(){var n=this.$createElement;return(this._self._c||n)("div",{attrs:{id:"plane"}},[this._v("plane")])},staticRenderFns:[]};var A=t("C7Lr")({name:"plane"},O,!1,function(n){t("DVFD")},"data-v-02df61e0",null).exports,_={render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{attrs:{id:"list"}},[t("h1",[n._v("My demo")]),n._v(" "),t("ul",n._l(n.list,function(e,l){return t("li",{key:l,on:{click:n.handleRoute}},[n._v(n._s(e))])}))])},staticRenderFns:[]};var F=t("C7Lr")({name:"mydemo",data:function(){return{list:["贪吃蛇","打飞机","打砖块","简易画板","俄罗斯方块"]}},methods:{handleRoute:function(n){this.$router.push("/demo/"+n.target.innerHTML)}}},_,!1,function(n){t("CO/4")},"data-v-a87c4720",null).exports,X={name:"draw",data:function(){return{list:["black","yellow","red","green","blue","clear","0"],color:"black",count:4}},methods:{drawing:function(n){var e=this.$refs.cans.getContext("2d"),t=n.offsetX,l=n.offsetY;e.beginPath(),e.moveTo(t,l),e.strokeStyle=this.color,e.lineWidth=this.count,window.onmousemove=function(n){var t=n.offsetX,l=n.offsetY;return e.lineTo(t,l),e.stroke(),!1},window.onmouseup=function(n){e.closePath(),window.onmousemove=window.onmouseup=null}},changeColor:function(n,e){e<this.list.length-2&&(this.color=n.target.innerHTML),e===this.list.length-2&&(this.color="white")},changeState:function(n,e){e===this.list.length-1&&(this.count=n.target.innerHTML)}},mounted:function(){document.body.style.background="black"}},T={render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{attrs:{id:"box"}},[t("canvas",{ref:"cans",attrs:{width:"500",height:"500"},on:{mousedown:n.drawing}}),n._v(" "),t("div",{attrs:{id:"control"}},[t("ul",n._l(n.list,function(e,l){return t("li",{key:l,attrs:{contenteditable:6==l},on:{click:function(e){n.changeColor(e,l)},blur:function(e){n.changeState(e,l)}}},[n._v(n._s(e)+"\n      ")])}))])])},staticRenderFns:[]};var I=t("C7Lr")(X,T,!1,function(n){t("hMVf")},"data-v-6c611aa0",null).exports,H={render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{attrs:{id:"tetris"}},[e("h1",[this._v("Trtris")]),this._v(" "),e("canvas",{ref:"cans",attrs:{width:"400",height:"400"}})])},staticRenderFns:[]};var E=t("C7Lr")({name:"Tetris",data:function(){return{gridding:"",drawMould:null,typeMould:1}},methods:{},mountd:function(){var n=this.$refs.cans.getContext("2d");this.drawMould=function(){1===this.typeMould&&(n.save(),n.fillRect(100,0,10,10),n.restore())}}},H,!1,function(n){t("PccH")},"data-v-72186cd3",null).exports,U={render:function(){var n=this.$createElement;return(this._self._c||n)("router-view")},staticRenderFns:[]};var D=t("C7Lr")({name:"myvue"},U,!1,function(n){t("IZM8")},"data-v-64b35c3b",null).exports,z={render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{attrs:{id:"myvue"}},[n._m(0),n._v(" "),t("ul",{staticClass:"list"},n._l(n.list,function(e,l){return t("li",{key:l,on:{click:function(e){n.handleRouter(l)}}},[n._v(n._s(e))])}))])},staticRenderFns:[function(){var n=this.$createElement,e=this._self._c||n;return e("header",[e("p",[this._v("Vue.js 学习笔记")])])}]};var R=t("C7Lr")({name:"vuelist",data:function(){return{list:["vue.js for begin","vue.js for second","vue.js for third","vue.js for fourth","vue.js for fifth","vue.js for sixth","vue.js for seventh","vue_atual"]}},mounted:function(){},methods:{handleRouter:function(n){this.$router.push("/myvue/"+(n+1))}}},z,!1,function(n){t("8V2Q")},"data-v-2e8636d6",null).exports,B=t("OqcS"),N=t.n(B),P={name:"vueone",data:function(){return{md:N.a}}},W={render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{attrs:{id:"one"}},[e("div",{directives:[{name:"highlight",rawName:"v-highlight"}],domProps:{innerHTML:this._s(this.md)}})])},staticRenderFns:[]};var Y=t("C7Lr")(P,W,!1,function(n){t("V8u8")},"data-v-1129c440",null).exports,G=t("e5cz"),Z=t.n(G),Q={name:"vuetwo",data:function(){return{md:Z.a}}},J={render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{attrs:{id:"two"}},[e("div",{directives:[{name:"highlight",rawName:"v-highlight"}],domProps:{innerHTML:this._s(this.md)}})])},staticRenderFns:[]};var K=t("C7Lr")(Q,J,!1,function(n){t("oYyU")},"data-v-197690ae",null).exports,$=t("9lDK"),nn=t.n($),en={name:"vuethree",data:function(){return{md:nn.a}}},tn={render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{attrs:{id:"three"}},[e("div",{directives:[{name:"highlight",rawName:"v-highlight"}],domProps:{innerHTML:this._s(this.md)}})])},staticRenderFns:[]};var ln=t("C7Lr")(en,tn,!1,function(n){t("ZT+L")},"data-v-dddb93c0",null).exports,on=t("FW3m"),sn=t.n(on),an={name:"vuefour",data:function(){return{md:sn.a}}},un={render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{attrs:{id:"four"}},[e("div",{directives:[{name:"highlight",rawName:"v-highlight"}],domProps:{innerHTML:this._s(this.md)}})])},staticRenderFns:[]};var dn=t("C7Lr")(an,un,!1,function(n){t("Vmih")},"data-v-5582c943",null).exports,cn=t("QplW"),rn=t.n(cn),pn={name:"vuefive",data:function(){return{md:rn.a}}},vn={render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{attrs:{id:"five"}},[e("div",{directives:[{name:"highlight",rawName:"v-highlight"}],domProps:{innerHTML:this._s(this.md)}})])},staticRenderFns:[]};var gn=t("C7Lr")(pn,vn,!1,function(n){t("yIGO")},"data-v-1e755e24",null).exports,mn=t("ZW+k"),hn=t.n(mn),fn={name:"vuesix",data:function(){return{md:hn.a}}},qn={render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{attrs:{id:"six"}},[e("div",{directives:[{name:"highlight",rawName:"v-highlight"}],domProps:{innerHTML:this._s(this.md)}})])},staticRenderFns:[]};var bn=t("C7Lr")(fn,qn,!1,function(n){t("rSm3")},"data-v-6b9329bc",null).exports,xn=t("nR5k"),yn=t.n(xn),wn={name:"vueseven",data:function(){return{md:yn.a}}},kn={render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{attrs:{id:"seven"}},[e("div",{directives:[{name:"highlight",rawName:"v-highlight"}],domProps:{innerHTML:this._s(this.md)}})])},staticRenderFns:[]};var jn=t("C7Lr")(wn,kn,!1,function(n){t("oGTq")},"data-v-486071bc",null).exports,Cn=t("0w3B"),Vn=t.n(Cn),Mn={name:"vueeight",data:function(){return{md:Vn.a}}},Ln={render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{attrs:{id:"eight"}},[e("div",{directives:[{name:"highlight",rawName:"v-highlight"}],domProps:{innerHTML:this._s(this.md)}})])},staticRenderFns:[]};var Sn=t("C7Lr")(Mn,Ln,!1,function(n){t("gxlC")},"data-v-2bde13fe",null).exports;l.default.use(s.a);var On=new s.a({routes:[{path:"/",component:u},{path:"/html",component:v},{path:"/css",component:m},{path:"/javascript",component:h.default},{path:"/profile",component:q},{path:"/demo",component:x,children:[{path:"贪吃蛇",component:M},{path:"打砖块",component:S},{path:"打飞机",component:A},{path:"list",component:F},{path:"简易画板",component:I},{path:"俄罗斯方块",component:E}],redirect:"/demo/list"},{path:"/blogs",component:j},{path:"/myvue",component:D,children:[{path:"list",component:R},{path:"1",component:Y},{path:"2",component:K},{path:"3",component:ln},{path:"4",component:dn},{path:"5",component:gn},{path:"6",component:bn},{path:"7",component:jn},{path:"8",component:Sn}],redirect:"/myvue/list"},{path:"/*",component:u}]}),An=t("9rMa");l.default.use(An.a);var _n=new An.a.Store({state:{},actions:{},mutations:{},getters:{}}),Fn=t("docE"),Xn=t.n(Fn),Tn=(t("glLB"),t("eh2P")),In=t.n(Tn);t("yk+x");l.default.directive("highlight",function(n){n.querySelectorAll("pre code").forEach(function(n){In.a.highlightBlock(n)})}),l.default.use(Xn.a),l.default.config.productionTip=!1,new l.default({el:"#app",router:On,components:{App:o},template:"<App/>",store:_n})},OVXi:function(n,e,t){"use strict";var l=t("Oc3k"),i=t.n(l),o=t("F+8y");var s=function(n){t("pfIa")},a=t("C7Lr")(i.a,o.a,!1,s,"data-v-2fff8a42",null);e.default=a.exports},OWNv:function(n,e){},Oc3k:function(n,e){},OqcS:function(n,e){n.exports='<h1 id="vue-js-to-begin">vue.js To Begin</h1>\n<h2 id="-vue-js">初识vue.js</h2>\n<ol>\n<li><p>构建数据驱动的web应用开发框架，属于前端框架</p>\n</li>\n<li><p>声明式渲染，应对前后端分离的大趋势</p>\n<ol>\n<li><pre><code class="language-javascript">var message = &#39;hello world&#39;;\n&lt;div&gt;message&lt;/div&gt;  \n页面显示：&lt;div&gt;hello world&lt;/div&gt;</code></pre>\n</li>\n<li><p>声明式渲染，同样是响应式。</p>\n</li>\n<li><p>node项目用的是混合式开发。把前端的代码，和ejs结合在一起。</p>\n</li>\n</ol>\n</li>\n<li><p>渐进式框架，适应各种业务需求以及场景</p>\n<ol>\n<li>适合新手，同样适合有一定经验的开发人员。</li>\n<li>小型，中型，大型项目都可以采用VUE框架开发。</li>\n<li>渐进式框架：非常容易上手，渐进增强。</li>\n</ol>\n</li>\n<li><p>适合移动端开发，SPA页面，即单页开发</p>\n<ol>\n<li>移动端网路不是很稳定。期望项目制作为单页面，尽量避免跳转页面。</li>\n<li>SPA页面，即单页面开发，适用于vue.js框架。</li>\n</ol>\n</li>\n<li><p>快速交付，结合第三方ui框架</p>\n<ol>\n<li>一个项目，用jQuery开发和用vue开发的对比，vue会节省30%移上的代码。</li>\n<li>接口很多，可以结合很多UI框架。</li>\n<li>jQueryUI框架：easyUI，minUI等。</li>\n<li>vue相关UI框架：elementUI,minUI等。</li>\n<li>查阅vue官网自行寻找。</li>\n</ol>\n</li>\n<li><p>侧重于数据。不需要操作DOM，框架自动操作。</p>\n</li>\n</ol>\n<h2 id="-">设计模式</h2>\n<ul>\n<li>每一种语言都是设计模式。<ul>\n<li>前人总结的一种开发经验。</li>\n<li>23种设计模式（book）<ul>\n<li>例如观察者模式</li>\n<li>工厂模式</li>\n<li>适配器模式等等</li>\n</ul>\n</li>\n<li>架构的设计模式（不属于23种设计模式）<ul>\n<li>MVC<ul>\n<li>model数据 views视图 controller控制器<ul>\n<li>利用控制器把数据和视图链接在一起</li>\n<li>view代码多 model代码相对多 control代码少</li>\n<li>node项目</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>MVP<ul>\n<li>model数据 views视图 presenter提出者<ul>\n<li>model和view代码相对多。presenter代码最多</li>\n<li>jQuery项目</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>MVVM（vue.js）<ul>\n<li>vm数据视图层<ul>\n<li>每层代码都很少</li>\n<li>vue.js 帮我们实现了vm层</li>\n<li>vue,js帮我们做了所有的DOM操作</li>\n<li>利用了双向数据绑定（observer）</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="-">开发环境搭建</h2>\n<ul>\n<li><p>vue.js v-2.*.*</p>\n</li>\n<li><p>声明式渲染</p>\n</li>\n<li><p>组件系统</p>\n</li>\n<li><p>路由机制</p>\n</li>\n<li><p>状态管理</p>\n</li>\n<li><p>安装方式</p>\n<ul>\n<li>直接引用vue.js</li>\n<li>利用npm安装</li>\n<li>利用cmd安装等</li>\n</ul>\n</li>\n<li><p>版本区别</p>\n<ul>\n<li><p>开发版本</p>\n<ul>\n<li><blockquote>\n<p>项目开发阶段使用，没有代码压缩，并且有错误提</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>生产版本</p>\n<ul>\n<li><blockquote>\n<p>正式版本，代码压缩，没有错误提示</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="vue-js-">VUE.JS的基本语法</h2>\n<h3 id="-">基本操作</h3>\n<pre><code class="language-html">&lt;script src=&quot;vue.js&quot;&gt;&lt;/script&gt;\n&lt;div id=&quot;app&quot;&gt;\n    {{message}},{{test}}\n&lt;/div&gt;\n&lt;div v-text=&quot;message&quot;&gt;\n\n&lt;/div&gt;\n&lt;script&gt;\n    //1.vue主要我们完成vm层开发\n    //2.el属性表示vue要控制的区域\n    //3.data数据对象，定义声明式的数据\n    //4.通过插值表达式{{js的执行环境}}，渲染页面。表达式中可以进行基本的js运算，可以写运算符，一些语法，但不能写语句。\n    //5.在vue中，基于面向对象的开发new Vue（）方式，在一个类中写了一个{}，这个叫配置参数。根据参数的不同，可以创建不同形态的对象。\n    //6.vm对象下，$ 和 _一般表示这些属性都是vue自带的属性和方法。\n    //7.vm.$data中的数据，挂载到了vm对象下，方便用户操作和内部使用。\n    //8.v-* :vue自带的指令（vue帮我实现了一些功能）\n    var vm = new VUE({\n        el:&#39;#app&#39;,\n        data:{\n            message:&#39;hellow vue&#39;,\n            test:&#39;我是一个测试文本&#39;\n        }\n    })\n&lt;/script&gt;</code></pre>\n<h3 id="vue-">VUE常用指令</h3>\n<ul>\n<li><p><code>v-*</code>  vue.js自带13种指令</p>\n</li>\n<li><p><code>v-text</code>  渲染数据。v-text=&quot;变量/&#39;字符串&#39;&quot;。直接渲染在标签内，作为标签的属性。不会解析html语法</p>\n</li>\n<li><p><code>v-html</code>  渲染数据。会自动解析html语法</p>\n<ul>\n<li>不建议在data数据中写html标签，这样解析html标签，不安全，可能会被攻击(XSS)，(CSRF)</li>\n</ul>\n</li>\n<li><p><code>v-once</code>  一次性插值。给标签添加v-once属性。关闭标签的响应式。可以在特定情况下提升性能</p>\n</li>\n<li><p><code>v-bind</code>  操作HTML属性。是vue中使用最为频繁的指令之一；可简写为:</p>\n<ul>\n<li><pre><code class="language-html">&lt;div v-bind:title=&quot;variable&quot;&gt;\n    用vue来管理title属性，这样title中的值就是一个变量（在data中赋值variable:&#39;这是用来显示的标题&#39;）\n&lt;/div&gt;</code></pre>\n</li>\n<li><pre><code class="language-html">&lt;div :title=&quot;true? &#39;box&#39; : &#39;box2&#39;&quot;&gt;\n    简写，省略了v-bind，只保留了:\n&lt;/div&gt;</code></pre>\n</li>\n</ul>\n</li>\n<li><p><code>v-on</code>  给html添加事件。同样是vue使用最为频繁的指令之一；可简写为@</p>\n<ul>\n<li><pre><code class="language-html">&lt;div v-on:click=&quot;show&quot; id=&quot;event&quot;&gt;\n\n&lt;/div&gt;\n&lt;div @click.stop=&quot;show&quot; id=&quot;event&quot;&gt;\n\n&lt;/div&gt;\n&lt;script&gt;\n    //vm对象中有一个methods用来写事件的方法\n    //methods属性中的方法同样会被自动挂载到vm对象中。也就是vm.methods.show === vm.show\n    var vm = new Vue({\n        el:&#39;event&#39;,\n        data:{\n\n        },\n        methods:{\n            show(){\n                console.log(123)\n            }\n        }\n    })\n&lt;/script&gt;</code></pre>\n</li>\n<li><p><code>.stop</code> - 调用 <code>event.stopPropagation()</code>。</p>\n</li>\n<li><p><code>.prevent</code> - 调用 <code>event.preventDefault()</code>。</p>\n</li>\n<li><p><code>.capture</code> - 添加事件侦听器时使用 capture 模式。</p>\n<ul>\n<li>触发捕获阶段。不触发冒泡阶段</li>\n</ul>\n</li>\n<li><p><code>.self</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</p>\n<ul>\n<li>停止事件流动。事件只在本身触发</li>\n</ul>\n</li>\n<li><p><code>.{keyCode | keyAlias}</code> - 只当事件是从特定键触发时才触发回调。</p>\n<ul>\n<li><code>&lt;div @keydown.13&gt;&lt;/div&gt;</code></li>\n</ul>\n</li>\n<li><p><code>.native</code> - 监听组件根元素的原生事件。</p>\n<ul>\n<li>组件标签上的事件都是自定义事件，需要用$emit触发</li>\n<li>可以通过加<code>.native</code>  ,使组件的自定义事件变成原生事件</li>\n</ul>\n</li>\n<li><p><code>.once</code> - 只触发一次回调。</p>\n</li>\n<li><p><code>.left</code> - (2.2.0) 只当点击鼠标左键时触发。</p>\n<ul>\n<li><blockquote>\n<p>还有 .enter .ctrl .alt .meta .space等等</p>\n<p>还可以在.enter.exact达到精确匹配的目的，（同时按下其他键无效）</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><code>.right</code> - (2.2.0) 只当点击鼠标右键时触发。</p>\n</li>\n<li><p><code>.middle</code> - (2.2.0) 只当点击鼠标中键时触发。</p>\n</li>\n<li><p><code>.passive</code> - (2.3.0) 以 <code>{ passive: true }</code> 模式添加侦听器</p>\n<ul>\n<li>提升移动端性能</li>\n<li>跟<code>.prevent</code> 完全相反的操作</li>\n<li>提前告诉浏览器我不去阻止默认行为，用来提升性能</li>\n</ul>\n</li>\n<li><p>对象语法（2.4.0+）</p>\n<ul>\n<li><pre><code class="language-html">&lt;button v-on=&quot;{ mousedown: doThis, mouseup: doThat }&quot;&gt;&lt;/button&gt;</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>v-show</code>  条件渲染</p>\n<ul>\n<li>与<code>v-if</code> 的区别是<code>v-show</code>是操作css属性display</li>\n<li><code>&lt;div v-show=&quot;true&quot;&gt;&lt;/div&gt;</code></li>\n<li>根据表达式的真假值，切换元素的display css属性</li>\n<li>当条件发生变化时该指令触发过度效果</li>\n<li>适用于频繁的显示隐藏</li>\n</ul>\n</li>\n<li><p><code>v-if</code>  条件渲染</p>\n<ul>\n<li>对html进行显示隐藏，对DOM进行原生的<em>appendchild</em>和<em>removechild</em></li>\n<li><code>&lt;div v-if=&quot;Math.rondam() &gt; 0.5&quot;&gt;&lt;/div&gt;</code></li>\n<li>根据表达式的值的真假条件渲染元素。在切换时，元素及它的数据绑定/组件被销毁并重建。</li>\n<li>但如果切换时，两个标签完全一样，vue会对便签进行复用（如<code>&lt;input&gt;</code>）</li>\n<li>如果元素时<code>&lt;template&gt;</code> ,将提出它的内容作为条件块。<code>&lt;template&gt;</code>标签不会出现在DOM节点上。是vue自定义的标签，用来充当临时容器。</li>\n<li>当条件发生变化时，该指令触发过渡效果</li>\n<li>适用于不频繁的显示隐藏</li>\n</ul>\n</li>\n<li><p><code>v-else-if</code>  条件渲染</p>\n<ul>\n<li><code>&lt;div v-else-if=&quot;Math.rondam() = 0.5&quot;&gt;&lt;/div&gt;</code></li>\n<li>前一个兄弟元素必须有<code>v-if</code>或<code>v-else-if</code>。</li>\n</ul>\n</li>\n<li><p><code>v-else</code>   条件渲染</p>\n<ul>\n<li><code>&lt;div v-else&gt;&lt;/div&gt;</code></li>\n<li>前一个兄弟元素必须有<code>v-if</code>或<code>v-else-if</code>。</li>\n</ul>\n</li>\n<li><p><code>v-for</code>   列表渲染</p>\n<ul>\n<li><p>基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 <code>alias in expression</code> ，为当前遍历的元素提供别名： </p>\n</li>\n<li><pre><code class="language-html">&lt;div v-for=&quot;item in items&quot;&gt;\n  {{ item }}\n&lt;/div&gt;\n&lt;script&gt;\n    var vm = new Vue({\n        el:&#39;#app&#39;,\n        data:{\n           items:[111,222,333] \n        }\n    })\n&lt;/script&gt;</code></pre>\n</li>\n<li><p>另外也可以为数组索引指定别名 (或者用于对象的键)： </p>\n</li>\n<li><pre><code class="language-html">&lt;div v-for=&quot;(item, index) in items&quot;&gt;{{item}},{{index}}&lt;/div&gt;&lt;!--返回数组的值，和索引-&gt;\n&lt;div v-for=&quot;(val, key) in object&quot;&gt;&lt;/div&gt;&lt;!--返回对象的值，和属性-&gt;\n&lt;div v-for=&quot;(val, key, index) in object&quot;&gt;&lt;/div&gt;&lt;!--返回对象的值，和属性，索引&gt;</code></pre>\n</li>\n<li><p>默认行为试着不改变整体，而是替换元素。迫使其重新排序的元素，你需要提供一个 <code>key</code> 的特殊属性： </p>\n</li>\n<li><pre><code class="language-html">&lt;div v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;\n  {{ item.text }}\n&lt;/div&gt;\n//key属性的作用区分不用的节点。否则vue会对节点进行复用</code></pre>\n</li>\n<li><p><em>item in items</em>可以用 <em>item of items</em> 代替 因为es6 有一个for of循环。趋势所使</p>\n<ul>\n<li><pre><code class="language-javascript">var arr = [1,2,3,4,5]\nfor(let v of arr){\n    console.log(v)\n}\n//for of 方法不支持对象的遍历，我们可以通过下面的方法解决这个问题\nObject.keys(obj);//把一个对象的属性转化成数组\nObject.values(obj);//把一个对象的值转化成数组\nObject.entries(obj);//把一个对象的属性和值转化成二维数组</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><code>v-model</code>  表单控件绑定</p>\n<ul>\n<li>限制<ul>\n<li><code>&lt;input&gt;</code></li>\n<li><code>&lt;select&gt;</code></li>\n<li><code>&lt;textarea&gt;</code></li>\n<li><code>&lt;components&gt;</code></li>\n</ul>\n</li>\n<li><code>&lt;input v-model=&quot;variable&quot; /&gt;</code></li>\n<li>修饰符<ul>\n<li><code>.lazy</code> - 取代 <code>input</code> 监听 <code>change</code> 事件<ul>\n<li>当光标移开输入框才能触发响应式</li>\n</ul>\n</li>\n<li><code>.number</code> - 输入字符串转为数字<ul>\n<li>输入框默认会把输入内容转成字符串</li>\n<li>表单返回值返回数字</li>\n</ul>\n</li>\n<li><code>.trim</code> - 输入首尾空格过滤<ul>\n<li>页面上看不到效果</li>\n<li>会在表单的返回值上表示</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>在表单控件或者组件上创建双向绑定。 在通过watch等方法实现实时更新</li>\n<li>如果<code>v-model=&quot;true&quot;</code>会默认选中单选框或多选框</li>\n</ul>\n</li>\n<li><p><code>v-pre</code>  跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache <a href="%E6%98%AF%E4%B8%80%E7%A7%8D%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E">^mustache</a>标签。跳过大量没有指令的节点会加快编译。</p>\n<ul>\n<li><code>&lt;div v-pre&gt;&lt;/div&gt;</code> </li>\n</ul>\n</li>\n<li><p><code>v-cloak</code>  隐藏渲染</p>\n<ul>\n<li>这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 <code>[v-cloak] { display: none }</code> 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。 </li>\n<li><code>&lt;div v-cloak&gt;&lt;/div&gt;</code></li>\n</ul>\n</li>\n</ul>\n<h3 id="computed-">Computed ：计算属性（对象）</h3>\n<ul>\n<li>computed对象里都是方法，但用的时候当属性来用。不需要调用</li>\n<li>同时我们也可以使用methods里面定义的函数，但这个函数必须调用，否则会在页面上直接显示代码</li>\n</ul>\n<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;\n    {{messageFn}}\n    {{messageMe()}}\n&lt;/div&gt;\n&lt;script&gt;\n    var vm = new Vue({\n        el:&#39;#app&#39;,\n        data:{\n\n        },\n        methods:{\n            messageMe(){\n                return &#39;hello world&#39;\n            }  \n        },\n        computed:{\n            messageFn(){\n               return &#39;hello world&#39;\n            }\n        }\n    })\n&lt;/script&gt;</code></pre>\n<ul>\n<li><p>优点</p>\n<ul>\n<li><p>跟插值表达式中写语法相比，要更简洁，方便。</p>\n</li>\n<li><p>跟methods相比，计算属性是基于他们的依赖进行缓存的，计算属性只有在相关依赖进行改变时，才会发生改变。所以要比methods跟快一些</p>\n</li>\n<li><p>所以我们不能直接更改computed定义的方法。如上面的例子vm.messageFn = xxx会报错。当时我们可以通过将computed定义的方法改成对象的写法来更改</p>\n<ul>\n<li><pre><code class="language-javascript">computed:{\n    messageFn:{\n        set(newVal){\n            this.message = newVal\n        },\n        get(){\n            return this.message       \n        }\n    }\n}</code></pre>\n</li>\n</ul>\n</li>\n<li><p>计算属性跟watch相比，更加简单易用</p>\n</li>\n<li><p>计算属性不适合异步数据操作</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="watch-">Watch 监听数据变化的属性（对象）</h3>\n<ul>\n<li>一般适用于异步的数据操作</li>\n</ul>\n<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;\n    {{messageFn}}\n    {{messageMe()}}\n&lt;/div&gt;\n&lt;script&gt;\n    var vm = new Vue({\n        el:&#39;#app&#39;,\n        data:{\n            message:&#39;hello world&#39;\n        },\n        methods:{\n            messageMe(){\n                return this.message\n            }  \n        },\n        computed:{\n            messageFn(){\n               return this.message\n            }\n        },\n        watch:{\n            message(newVal,oldVal){\n                //当message属性发生变化时，触发\n                console.log(&#39;新值&#39;,newVal);\n                console.log(&#39;旧值&#39;,oldVal)\n            }\n        }\n    })\n&lt;/script&gt;</code></pre>\n<h3 id="class-style-">Class 与 Style的绑定</h3>\n<ul>\n<li><p><em>class</em> 的对象语法</p>\n<ul>\n<li><blockquote>\n<p><code>&lt;div :class=&quot;{{box:true , white: false}}&quot;&gt;&lt;/div&gt;</code></p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><em>class</em> 的数组的语法</p>\n<ul>\n<li><blockquote>\n<div :class="[box,box2,box3]"></div>\n\n<p>data{</p>\n<p>​    box:{box:ture},</p>\n<p>​    box2:{box2:ture},</p>\n<p>​    box3:{box3.true}</p>\n<p>}</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><em>style</em> 的对象语法</p>\n<ul>\n<li><blockquote>\n<p><code>&lt;div :style=&quot;{background:&#39;red&#39;,height:&#39;100px&#39;,height:&#39;100px&#39;}&quot;</code></p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><em>style</em> 的数组语法同<em>class</em> 的数组语法</p>\n<ul>\n<li><blockquote>\n<p>此处不枚举</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="vue-js-">Vue.js 的数组方法</h3>\n<ul>\n<li><p>变异的数组方法，具有响应式（已经不是原生的啦）</p>\n<ul>\n<li><code>push()</code></li>\n<li><code>unshift()</code></li>\n<li><code>pop()</code></li>\n<li><code>shift()</code></li>\n<li><code>splice()</code></li>\n<li><code>reverse()</code></li>\n<li><code>sort()</code></li>\n</ul>\n</li>\n<li><p>其他的数组方法均没有响应式。可以通过查看构造函数是否带有_<em>Observer_</em>进行判断</p>\n<ul>\n<li><p>可以通过重新赋值，来实现没有响应式的数组方法，进行响应式</p>\n</li>\n<li><p>复习数组的filter(),map(),find(),findIndex()方法</p>\n<ul>\n<li><pre><code class="language-javascript">filter(callback)//过滤数组，值为真留下来，值为假过滤掉。不能改变原数组，重新生成数组\nvar arr = [1,2,3,4,5,6]\narr = arr.filter((val)=&gt;{\n    return val%2\n})\n//则得到的数组是我们过滤掉偶数的新数组</code></pre>\n</li>\n<li><pre><code class="language-javascript">map(callback)//重新映射数组，对数组的每一项进行重新的返回。不能改变原数组，重新生成数组\nvar arr = [1,2,3,4,5,6]\narr = arr.map((val)=&gt;{\n    return val*val\n})\n//得到一个新数组，每个值为旧数组的每个值得平方</code></pre>\n</li>\n<li><pre><code class="language-javascript">find(callback)//返回数组中，符合条件的第一个元素</code></pre>\n</li>\n<li><pre><code class="language-javascript">findIndex(callback)//返回数组中，符合条件的第一个元素的索引</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n'},PALI:function(n,e){},PccH:function(n,e){},QplW:function(n,e,t){n.exports='<h1 id="vue-js-five-days">Vue.js five days</h1>\n<h2 id="vue-js-router">Vue.js Router</h2>\n<ul>\n<li><p>后端路由</p>\n<ul>\n<li>多个页面跳转。</li>\n</ul>\n</li>\n<li><p>前端路由</p>\n<ul>\n<li>做spa页面跳转的，只有一个页面</li>\n<li>通过hash + onhashchange原理</li>\n<li>或通过history + onpop + pushstate 原理</li>\n</ul>\n</li>\n<li><p>使用vue的路由</p>\n<ul>\n<li><p>安装vue-router模块，并创建单独的router.js文件</p>\n<ul>\n<li><code>cnpm i -S vue-router</code>    </li>\n</ul>\n</li>\n<li><pre><code class="language-js">import Vue from &#39;vue&#39;\nimport VueRouter from &#39;vue-router&#39;\n//初始化路由\nVue.use(VueRouter);\n//定义路由\nconst Foo = {template:&#39;&lt;div&gt;foo&lt;/div&gt;&#39;}//foo组件\nconst routes = [\n    {path:&#39;/foo&#39;,component:Foo},\n    {path:&#39;/*&#39;,component:&#39;/404&#39;}//页面重定向(状态码302)\n]\n//注册路由\nconst router = new VueRouter({\n    method:&#39;history&#39;//选取模式，历史模式和哈希模式\n    routes\n})\nexport default router</code></pre>\n</li>\n<li><pre><code class="language-javascript">//在main.js 中引入\nimport router form &#39;./router/router.js&#39;\nnew Vue({\n    router\n})</code></pre>\n</li>\n</ul>\n</li>\n<li><p>路由搭建完毕，路由插座</p>\n<ul>\n<li>展示组件的区域</li>\n<li>通过<code>&lt;router-view&gt;&lt;/router-view&gt;</code>嵌入页面</li>\n</ul>\n</li>\n<li><p>路由的句柄（点击跳转路由）</p>\n<ul>\n<li>通过<code>&lt;router-link to=&quot;/foo&quot;&gt;&lt;/router-link&gt;</code>来实现<ul>\n<li>这个标签默认在页面上渲染成<code>&lt;a&gt;</code>标签</li>\n<li>可以通过tag属性指定渲染标签<code>tag=&quot;button&quot;</code></li>\n<li>还可以通过<code>.router-link-active:{}</code>来指定被渲染的<code>&lt;router-link&gt;</code>标签的样式</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>路由的嵌套（二级路由+）</p>\n<ul>\n<li><p>一级路由配置中配置二级路由</p>\n</li>\n<li><pre><code class="language-javascript">const routes = [\n    {\n        path:&#39;/foo&#39;,\n        component:Foo,//在一级路由的template标签中插入二级路由的&lt;router-view&gt;标签\n        children:[\n            {\n                path:&#39;imtwo&#39;,//注意这里没有/ ，否则会被认为是绝对路径，不写是相对路径\n                component:xxx\n            }\n        ],\n        redirect:&#39;/foo/imtwo&#39;\n        //设置进入foo路由后，默认跳转到/foo/intwo这个二级路由\n    },\n\n]</code></pre>\n</li>\n</ul>\n</li>\n<li><p>动态路由</p>\n<ul>\n<li><p>根据类似的一批url，可以跳转到同一个组件</p>\n</li>\n<li><pre><code class="language-javascript">//通过在配置路由时，设置路径来实现动态路由\n{\n    path:&#39;/foo/:variable&#39;,component:foo\n}\n//variable是变量我们可以在生命周期中或其他时期通过 this.$route.params.variable来获取url上面的值    </code></pre>\n</li>\n</ul>\n</li>\n<li><p>编程式路由</p>\n<ul>\n<li>在js中进行路由跳转，叫做编程式路由</li>\n<li>vue的实现<code>$router.push(&#39;/details&#39;)</code></li>\n</ul>\n</li>\n</ul>\n<h2 id="vuex-">Vuex 状态管理</h2>\n<ul>\n<li><p>vuex是第三方模块</p>\n<ul>\n<li>借鉴了<em>flux</em>架构思想</li>\n</ul>\n</li>\n<li><p>Vuex状态管理模块</p>\n<ul>\n<li>状态===数据</li>\n<li>做非父子组件通信，适合做中大型项目</li>\n<li>不适合父子通信</li>\n</ul>\n</li>\n<li><p>图示</p>\n<ul>\n<li>vuex是单项是数据流动</li>\n<li>组件向改变state中的数据<ul>\n<li>dispatch-&gt;actions-&gt;commit-&gt;mutations-&gt;mutate-&gt;state异步操作</li>\n<li>commit-&gt;mutations-&gt;mutate-&gt;state同步操作<ul>\n<li>为什么不能在mutations做异步操作，会影响devtools这个工具，跟踪不到数据的变化</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><img src="'+t("DCME")+'" alt=""></p>\n</li>\n<li><p>具体操作</p>\n<ol>\n<li><p>局部安装 <code>cnpm i -S vuex</code></p>\n<ol>\n<li>在<code>src</code>文件夹下创建store文件夹，在这个文件夹下创建store.js</li>\n</ol>\n</li>\n<li><p>了解Devtools调试工具</p>\n<ol>\n<li>配置是否允许 <a href="https://github.com/vuejs/vue-devtools">vue-devtools</a> 检查代码。开发版本默认为 <code>true</code>，生产版本默认为 <code>false</code>。生产版本设为 <code>true</code> 可以启用检查。 </li>\n<li>在Chrome商店下载，或在百度上下载</li>\n<li>通过chrome的扩展程序来扩展这个调试工具</li>\n<li>这个工具同步监听了mutations中发生的变化</li>\n</ol>\n</li>\n<li><p>vuex的核心内容</p>\n<ol>\n<li>State ： 存储共享的状态（数据）</li>\n<li>Getter：vuex的计算属性</li>\n<li>Mutations：来实现状态的同步操作</li>\n<li>Action：来实现状态的异步操作</li>\n<li>Module：多状态管理模块划分</li>\n</ol>\n</li>\n<li><p><code>store.js</code>文件内容</p>\n<ol>\n<li><pre><code class="language-javascript">import Vue from &#39;vue&#39;\nimport Vuex from &#39;vuex&#39;\n//初始化vuex\nVue.use(Vuex);\n//定义vuex配置\nconst store = new Vuex.Store({\n    //定义公共状态\n    state:{\n        count:0\n    },\n    actions：{\n        //用于异步操作，方法名也都是大写的\n            CHANGE_COUNT_ACT(context,payload){\n            setTimeout(()=&gt;{\n                //context 执行上下文，相当于this，这里是$store\n                context.commit(&#39;CHANG_COUNT&#39;,payload)\n            },1000)\n        }\n    },\n    mutations:{\n        //这里的方法名都是大写的\n        //用于同步操作，不能进行异步操作，否则devtools检测不到\n        CHANGE_COUNT(state,payload){\n            state.count++\n            console.log(payload)//可以接收数据\n        }\n    },\n    getters:{\n        //计算属性：用法和computed一样，可以当做属性传递\n        computed(state){\n            return state\n        }\n    }\n\n})\n//提供对外接口\nexport default store</code></pre>\n</li>\n<li><p><code>main.js</code>中操作</p>\n<pre><code class="language-javascript">import store from &#39;./store/store.js&#39;\nnew Vue({\n    store\n})</code></pre>\n</li>\n<li><p>这样我们就能通过<code>$store.state.count</code>来获取<code>state</code>中定义的数据了</p>\n</li>\n<li><p>如何修改<code>state</code>中的数据</p>\n<ol>\n<li>通过在<code>mutations</code>中定义方法,可以通过<code>$store.commit(&#39;CHANGE_COUNT&#39;,123)</code>来触发<ol>\n<li>第二个参数为想传递的数据</li>\n</ol>\n</li>\n<li>通过在<code>action</code>中定义的方法，可以通过<code>$store.dispatch(&#39;CHANGE_COUNT_ACT&#39;,payload)</code>来触发<ol>\n<li>我们在这里进行异步操作。</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li><p><code>vuex</code>的简写操作</p>\n<ul>\n<li><p><code>state</code>  =&gt; <code>mapState</code></p>\n<ul>\n<li><pre><code class="language-javascript">import {mapState} from &#39;vuex&#39;;\nmethods:{\n    ...mapState([&#39;xxx&#39;,&#39;xxxx&#39;])\n}</code></pre>\n</li>\n</ul>\n</li>\n<li><p><code>getters</code>  =&gt; <code>mapGetters</code></p>\n</li>\n<li><p><code>mutations</code>  =&gt; <code>mapMotations</code></p>\n</li>\n<li><p><code>actions</code>  =&gt; <code>mapActions</code></p>\n</li>\n<li><p>利用es6的展开运算符<code>...</code></p>\n<ul>\n<li><p>```javascritp\nvar a = [1,2,3,4];\nvar b = a;\nb.push(5)\n//影响了a</p>\n<p>//利用展开运算符进行堆的复制\nvar b = [...a]</p>\n<p>/////////////////////////////\nvar obj = {</p>\n<pre><code>username:&#39;xiaoming&#39;</code></pre><p>}</p>\n<p>var cloneObj = {...obj}</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<pre><code>     ```</code></pre><ol start="6">\n<li><p><code>modules</code>中可以引入其他的状态管理，进行模块化划分</p>\n<pre><code class="language-js">export default {\n    state:{},\n    getters:{},\n    actions:{},\n    mutations:{}\n}</code></pre>\n<pre><code class="language-js">import moduleA from &#39;xxx.js&#39;\n\nconst store = new Vuex.Store({\n    modules:{\n        moduleA:moduleA\n    }\n})\n//注意 模块是作为整体输出的\n//在你的state属性必须用mapState，且mapState中的值作为对象的形式存在，且对应一个函数</code></pre>\n</li>\n</ol>\n'},Twv2:function(n,e){},UZOl:function(n,e){},V8u8:function(n,e){},Vmih:function(n,e){},"ZT+L":function(n,e){},"ZW+k":function(n,e){n.exports='<h1 id="vue-js-about-project">Vue.js About Project</h1>\n<h2 id="swiper-">swiper 框架</h2>\n<ul>\n<li><p>移动端轮播图</p>\n</li>\n<li><p>移动端滑动菜单</p>\n</li>\n<li><p><code>swiper.com.cn</code></p>\n</li>\n<li><p>必须等待DOM全部加载完毕后才生效</p>\n<ul>\n<li>用vm.$nextTick().then(callback)</li>\n</ul>\n</li>\n<li><pre><code class="language-html">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;swiper-4.3.5.min.css&quot;&gt;\n    &lt;style&gt;\n    #banner{ width:400px; height:200px; border:1px black solid; margin:20px auto;}\n    #banner .swiper-slide{ text-align: center; line-height: 200px; background:red;}\n\n    #list{ width:400px; height:30px; border:1px black solid; margin:20px auto;}\n    #list .swiper-slide{ width:50px; text-align: center; line-height: 30px; }\n    &lt;/style&gt;\n    &lt;script src=&quot;swiper-4.3.5.min.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=&quot;banner&quot; class=&quot;swiper-container&quot;&gt;\n        &lt;div class=&quot;swiper-wrapper&quot;&gt;\n            &lt;div class=&quot;swiper-slide&quot; style=&quot;background:red&quot;&gt;Slide 1&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot; style=&quot;background:hotpink&quot;&gt;Slide 2&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot; style=&quot;background:blue&quot;&gt;Slide 3&lt;/div&gt;\n        &lt;/div&gt;\n        &lt;!-- 如果需要分页器 --&gt;\n        &lt;!-- &lt;div class=&quot;swiper-pagination&quot;&gt;&lt;/div&gt; --&gt;\n        &lt;div class=&quot;swiper-pagination swiper-pagination-fraction&quot;&gt;\n            &lt;span class=&quot;swiper-pagination-current&quot;&gt;1&lt;/span&gt; / &lt;span class=&quot;swiper-pagination-total&quot;&gt;3&lt;/span&gt;\n        &lt;/div&gt;\n        &lt;!-- 如果需要导航按钮 --&gt;\n        &lt;div class=&quot;swiper-button-prev&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;swiper-button-next&quot;&gt;&lt;/div&gt;    \n        &lt;!-- 如果需要滚动条 --&gt;\n           &lt;div class=&quot;swiper-scrollbar&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;div id=&quot;list&quot; class=&quot;swiper-container&quot;&gt;\n        &lt;div class=&quot;swiper-wrapper&quot;&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;首页&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;新闻&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;视频&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;首页&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;新闻&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;视频&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;首页&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;新闻&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;视频&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;首页&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;新闻&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;视频&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;首页&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;新闻&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;视频&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;首页&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;新闻&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;视频&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;首页&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;新闻&lt;/div&gt;\n            &lt;div class=&quot;swiper-slide&quot;&gt;视频&lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;script&gt;\n    /*var mySwiper = new Swiper(&#39;#banner&#39;, {});*/\n\n    /*var mySwiper = new Swiper(&#39;#banner&#39;, {\n        //loop : true,\n        direction: &#39;vertical&#39;,\n        //autoplay : true,\n        autoplay : {\n            delay : 2000\n        },\n        speed : 3000\n    });*/\n\n    var mySwiper = new Swiper(&#39;#banner&#39;, {\n        effect: &#39;fade&#39;,\n        pagination: {\n          el: &#39;.swiper-pagination&#39;,\n          type : &#39;fraction&#39;\n        },\n        navigation: {\n          nextEl: &#39;.swiper-button-next&#39;,\n          prevEl: &#39;.swiper-button-prev&#39;\n        },\n        scrollbar: {\n          el: &#39;.swiper-scrollbar&#39;\n        }\n    });\n\n    var mySwiper = new Swiper(&#39;#list&#39;,{\n        freeMode : true,   // 随意滑动距离\n        slidesPerView: &#39;auto&#39;,  //根据每一项自身的宽度来适应容器\n        freeModeSticky: true //滑动到每一项的端点\n    }); \n\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n</li>\n</ul>\n<h2 id="fetch">Fetch</h2>\n<ul>\n<li><p>ES6的新提供的一种ajax操作，基于<code>promise</code>来设计的</p>\n</li>\n<li><p>后端接收到数据的格式</p>\n<ul>\n<li><code>GET</code>：字符串</li>\n<li><code>POST</code>：字符串，JSON，二进制</li>\n</ul>\n</li>\n<li><pre><code class="language-javascript">//GET\nfetch(&#39;data.php?message=hellow&#39;).then((res)=&gt;{\n    console.log(res);\n    return res.json()//先转化json格式，这里的res是一个对象\n}).then((data)=&gt;{\n    console.log(data)//这里的data是服务器返回的数据\n})\n\n//POST（默认上传JSON）\nfetch(&#39;data.php,{\n      method:&#39;POST&#39;,\n      headers:{\n          &#39;Content-type&#39;:&#39;application/x-www-form-urlencoded&#39;//默认是jsonp的格式，这里给转化成字符串\n      }\n      body:&#39;这是我上传的数据&#39;\n      }).then((res)=&gt;{\n    console.log(res);\n    return res.json()//先转化json格式，这里的res是一个对象\n}).then((data)=&gt;{\n    console.log(data)//这里的data是服务器返回的数据，会把后端格式自动转化为字符串\n})</code></pre>\n</li>\n</ul>\n<h2 id="axios">Axios</h2>\n<ul>\n<li><p>下载axios.js文件</p>\n</li>\n<li><pre><code class="language-html">&lt;script src=&quot;./axios.js&quot;&gt;&lt;/script&gt;\n&lt;script&gt;\n    //get\n    axios.get(&#39;data.php&#39;,{\n        params:{\n            message:&#39;hellow&#39;//这里是向后端发送的数据\n        }\n    })then((res)=&gt;{\n        console.log(res)//同样是一个对象，但这个对象中直接由一个属性就是我们要请求的数据\n        console.log(res.data)//会把后端格式自动解析为字符串\n    })\n    //post 默认传给后端是json格式\n    var options = {\n        method:&#39;POST&#39;,\n        url:&#39;data.php&#39;,\n        headers:{\n            &#39;Content-Type&#39;:&#39;application-x-www-form-urlencoded&#39;//自定义请求头部类型\n        }\n        data:&#39;message=hellow&#39;//不支持对象\n    }\n    axios(options).then((res)=&gt;{\n        console.log(res)//同样是一个对象，但这个对象中直接由一个属性就是我们要请求的数据\n        console.log(res.data)//会把后端格式自动解析为字符串\n    })\n&lt;/script&gt;</code></pre>\n</li>\n</ul>\n<h2 id="cros-">CROS 跨域资源共享</h2>\n<ul>\n<li><p>针对浏览器安全策略（同源策略）</p>\n</li>\n<li><p>一下这几种类型设计到跨域</p>\n<ul>\n<li>域名不同</li>\n<li>协议不同</li>\n<li>端口不同</li>\n<li>ip和域名</li>\n</ul>\n</li>\n<li><p>解决方式</p>\n<ul>\n<li>jsonp：利用<code>script</code>标签来实现</li>\n<li>cors：服务器设置白名单</li>\n<li>反向代理</li>\n<li>domain</li>\n<li>window.name</li>\n<li>iframe</li>\n<li>postMessage</li>\n<li>正向代理</li>\n<li>websocket</li>\n<li>flash</li>\n</ul>\n</li>\n<li><p>CORS跨域资源共享</p>\n<ul>\n<li><pre><code class="language-php">//后端:设置白名单\n&lt;?php\n    header(&#39;Access-Control-Allow-Origin:http://xxxxx&#39;)\n    ?&gt;</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="-">反向代理</h2>\n<ul>\n<li><p>前端通过访问后端，由后端反向代理访问其它网站后端，来获取数据</p>\n</li>\n<li><pre><code class="language-javascript">vue通过webpack-dev-server来实现的服务器。\n所以我们可以在webpack-dev-server的配置文件中的proxyTable属性来设置反向代理\nproxyTable:{\n    &#39;/v4/api/*&#39;:{\n        target:&#39;https://m.maizuo.com/&#39;,\n        host:&#39;m.maizuo.com&#39;,\n        changeOrigin:true    \n    }\n}\n///v4/api/为我们想代理的或后端向访问的文件夹。</code></pre>\n</li>\n</ul>\n<h2 id="-">移动端事件与框架</h2>\n<ul>\n<li><p>移动端事件</p>\n<ul>\n<li><code>ontouchstart</code> ==&gt;onmousedown</li>\n<li><code>ontouchmove</code>==&gt; onmousemove</li>\n<li><code>ontouchend</code>==&gt;onmouseup</li>\n</ul>\n</li>\n<li><p>移动端的事件对象</p>\n<ul>\n<li>移动端的事件对象跟pc端事件对象并不是完全相同</li>\n<li>他有touch对象是一个伪数组，var touch = evt.changeTouches   这里存放着clientX,clientY等</li>\n</ul>\n</li>\n<li><p>zepto库</p>\n<ul>\n<li><p>用法类似jQuery</p>\n</li>\n<li><p>这个库提供了许多移动端的事件</p>\n<ul>\n<li>滑屏</li>\n<li>触屏</li>\n<li>长按</li>\n<li>双指</li>\n<li>等等</li>\n</ul>\n</li>\n<li><pre><code class="language-javascript">//利用zepto监听滑屏事件(任何方向滑动都可以触发)（swipeLeft左滑事件）\n$(&#39;#box&#39;).on(&#39;swipe&#39;,()=&gt;{\n\n})\n//监听触屏事件，类似原生的touchstart。但原生的touchstart无法区分滑动和点击，只要手指按下就会触发。tap不会。同样还有singleTap单点事件，doubleTap双击事件，langTap长按事件\n$(&#39;#box&#39;).on(&#39;tap&#39;,()=&gt;{\n\n})\n//监听双指操作事件。\n//pinch双指放大缩小都会触发\n//pinchIn双指放大\n//pinchOut双指缩小\n$(&#39;#box&#39;).on(&#39;pinch&#39;,()=&gt;{\n\n})</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="-">逻辑运算符的本质</h2>\n<ul>\n<li>五大运算符之一</li>\n<li>&amp;&amp;运算符<ul>\n<li>本质：前面的值为真就返回后面的值，前面的值为假就返回前面的值</li>\n</ul>\n</li>\n<li>|| 运算符<ul>\n<li>本质：前面的值为真就返回前面的值，前面的值为假就返回后面的值</li>\n</ul>\n</li>\n</ul>\n<h2 id="git">GIT</h2>\n<ul>\n<li>git工具<ul>\n<li>版本控制工具，是一种记录一个或者若干个文件内容变化，以便将来在特定版本修订情况的系统。</li>\n<li>在项目中进行多人写作开发</li>\n<li>下载地址<ul>\n<li><a href="https://git-scm.com/">https://git-scm.com/</a></li>\n<li><a href="https://desktop.github.com">https://desktop.github.com</a></li>\n</ul>\n</li>\n<li>github网站<ul>\n<li>程序员社交平台。开源项目库，远程仓库，个人博客等。</li>\n<li><a href="https://githun.com">https://githun.com</a></li>\n<li>中国版：码云</li>\n</ul>\n</li>\n<li>集成式管理工具<ul>\n<li>所有项目版本都在中央服务器上</li>\n<li>必须要网络</li>\n<li>cvs，svn</li>\n</ul>\n</li>\n<li>分布式管理工具<ul>\n<li>每一台电脑中都有版本</li>\n<li>git</li>\n</ul>\n</li>\n<li>下载安装</li>\n</ul>\n</li>\n<li>使用bash<ul>\n<li>git自带的命令行操作窗口<ul>\n<li>支持Linux命令</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>git的配置<ul>\n<li>git config --list查看配置菜单</li>\n<li>git config --global user.name &quot;xxx&quot;配置贡献者姓名</li>\n<li>git config --global user.email &quot;xxx&quot;配置贡献者邮箱</li>\n<li>git config --global --unset user.name 删除配置</li>\n</ul>\n</li>\n<li>git的三个区<ul>\n<li>工作区（Gitstudy文件夹）<ul>\n<li>在这个文件夹下右键打开bash命令行</li>\n<li>输入命令git init初始化git环境</li>\n</ul>\n</li>\n<li>暂存区（.git文件夹）</li>\n<li>版本区（.git文件夹）<ul>\n<li>主分支master</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>git的常用命令<ul>\n<li>git init初始化环境</li>\n<li>git status    查看git的状态<ul>\n<li>工作区文件与缓存区，版本区有区别，则文件显示红色</li>\n<li>工作区文件与缓存区一样，版本区有区别，则显示绿色</li>\n<li>工作区文件与缓存区，版本区一致，则显示白色</li>\n</ul>\n</li>\n<li>git add xxx   将xxx文件添加到缓存区<ul>\n<li>git add . 将所有文件添加到暂存区</li>\n</ul>\n</li>\n<li>git commit -m  将暂存区的所有文件提交到版本区（-m “嘻嘻嘻嘻嘻嘻嘻” 为这次提交文件的注释）<ul>\n<li>git commit -a -m 一次性将已经被管理过得文件提交到版本区（-a是add的简写）</li>\n</ul>\n</li>\n<li>git log 输出所有日志</li>\n<li>git diff 对比文件差异<ul>\n<li>git diff 工作区与缓存区的对比</li>\n<li>git diff --cached（--staged） 缓存区与版本区的对比</li>\n<li>git diff master 工作区与版本区的对比（master为分支的名字）</li>\n</ul>\n</li>\n<li>git reset HEAD xxx 撤销版本区最新版本xxx文件到缓存区  也叫检出<ul>\n<li>git checkout --xxx 从缓存区或版本区撤销最新版本到工作区</li>\n<li>git checkout id --xxx 从缓存区或版本区将指定id版本文件撤销到工作区</li>\n</ul>\n</li>\n<li>git rm xxx 将文件删除（git commit -m 提交后，这个文件在这个版本就彻底不存在了）<ul>\n<li>git rm -f xxx 强制将文件从工作区删除</li>\n<li>git rm --cached xxx 将文件从缓存区删除</li>\n</ul>\n</li>\n<li>git reset --hard id 将工作区恢复到指定版本<ul>\n<li>与撤销的区别，撤销版本，版本区不会发生变化</li>\n<li>恢复版本，版本区指定版本后的版本都不存在了</li>\n<li>git reflog 输出最近操作的日志<ul>\n<li>我们可以通过git reflog 打印出恢复版本后丢失的版本号，在重新找回丢失版本</li>\n</ul>\n</li>\n<li>git reset --hard HEAD^ 使指针指向上一个版本，恢复到上一个版本</li>\n</ul>\n</li>\n<li>HEAD指针<ul>\n<li>git中有一个head指针，指向了最新版本，我们其实通过head指针，来获取版本</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="github-">GitHub 远程仓库</h2>\n<ul>\n<li><p>SSH安全协议</p>\n<ul>\n<li><p>指定电脑允许在GitHub上传文件</p>\n</li>\n<li><p>先检查电脑administrator下是否有.ssh文件</p>\n</li>\n<li><p>没有在git命令行中输入ssh-keygen -t rsa -C &quot;<a href="mailto:youremail@example.com">youremail@example.com</a>&quot;（你自己的邮箱）</p>\n</li>\n<li><p>打开生成的.ssh文件</p>\n</li>\n<li><p>在GitHub中配置</p>\n</li>\n<li><p>git remote 查看远程连接</p>\n</li>\n<li><p>git remote -v 查看具体远程连接路径</p>\n</li>\n<li><pre><code>git remote add origin https://github.com/upeartaker/mobile_maizuo.git添加一个远程连接路径，并起名为origin，指定路径为https://github.com/upeartaker/mobile_maizuo.git</code></pre></li>\n<li><p>git push orgin master 选择要上传远程连接名字，以及要上传的分支</p>\n</li>\n</ul>\n</li>\n<li><p>多人协作</p>\n<ul>\n<li>接受邀请</li>\n<li>git clone + adress 克隆一个git仓库</li>\n<li>解决多人写作会造成同一代码多人修改产生冲突的问题<ul>\n<li>git pull branch<ul>\n<li>下载文件，并进行对比</li>\n</ul>\n</li>\n<li>git fetch<ul>\n<li>下载文件，不进行对比</li>\n<li>通过git diff master origin / master</li>\n<li>通过git merge origin/master进行对比</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>操作分支</p>\n<ul>\n<li>git branch 查看当前分支</li>\n<li>git branch xxx 新建一个分支</li>\n<li>git branch -d xxx 删除一个分支</li>\n<li>git checkout xxx选择分支</li>\n<li>git checkout -b 创建并切换一个新分支</li>\n<li>git merge xxx 合并指定分支（注意分支不会消失，需要自己删除）</li>\n</ul>\n</li>\n<li><p>操作里程碑</p>\n<ul>\n<li>git tag v1.0.0 添加一个里程碑</li>\n<li>git push origin v1.0.0 上传里程碑</li>\n</ul>\n</li>\n</ul>\n'},e5cz:function(n,e){n.exports='<h1 id="vue-js-second-days">Vue.js Second Days</h1>\n<h2 id="vue-js-event">Vue.js Event</h2>\n<ul>\n<li><p>监听事件直接触发代码</p>\n<ul>\n<li><pre><code class="language-html">&lt;div @click=&quot;message = &#39;hello&quot;&gt;\n    {{message}}\n&lt;/div&gt;</code></pre>\n</li>\n</ul>\n</li>\n<li><p>方法事件处理器（写函数名）</p>\n<ul>\n<li><pre><code class="language-html">&lt;div @click=&quot;handleClick&quot; id=&quot;app&quot;&gt;\n\n&lt;/div&gt;\n&lt;script&gt;\n    var vm = new Vue({\n        el:&quot;#app&quot;,\n        methods:{\n            handleClick(evt){\n                console.log(evt)//可以直接获取\n            }\n        }\n    })\n&lt;/script&gt;</code></pre>\n</li>\n</ul>\n</li>\n<li><p>内联处理器方法（执行函数表达式）</p>\n<ul>\n<li><pre><code class="language-html">&lt;div @click=&quot;handleClick($event)&quot; id=&quot;app&quot;&gt;\n\n&lt;/div&gt;\n&lt;script&gt;\n    var vm = new Vue({\n        el:&quot;#app&quot;,\n        methods:{\n            handleClick(evt){\n                console.log(evt)//传递参数才可获取。同时可以传递多个参数。\n            }\n        }\n    })\n&lt;/script&gt;</code></pre>\n</li>\n</ul>\n</li>\n<li><p>为什么在HTML上监听事件</p>\n<ul>\n<li>你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 <code>v-on</code> 有几个好处： <ul>\n<li>扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。 </li>\n<li>因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。 </li>\n<li>当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>扩展es6字符串匹配方法</p>\n<ul>\n<li><pre><code class="language-javascript">var str = &#39;hellow&#39;\nvar search = &#39;e&#39;\nstr.includes(search)//返回布尔值。找到就是true，没有就是false。\n\n//与es5的indexOf的区别。es5的方法返回的是索引</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="vue-">Vue的一些默认行为</h2>\n<ul>\n<li>vue中默认对一样的标签是进行复用的，这样可以减少DOM操作，提升性能<ul>\n<li>但是这种行为对于列表渲染的情况，性能是下降的。所以我们可以应用<code>:key</code>来解决这个问题</li>\n<li>不能用index作为<code>key</code>的值，因为索引的变化的</li>\n</ul>\n</li>\n</ul>\n<h2 id="vue-js-">Vue.js 生命周期</h2>\n<ul>\n<li><p>每个vue实例在创建之前，都会进行一系列的初始化过程。同时在这个过程中也会运行一些叫生命周期钩子的函数，给与用户在一些特定的时期，使用他们自己的函数。</p>\n</li>\n<li><p>如果想扩展自己的代码到vue中。</p>\n<ul>\n<li>不能直接改源码，我们目前没有那种能力</li>\n<li>利用生命周期钩子，在vue.js以外的代码区域进行修改</li>\n</ul>\n</li>\n<li><p>生命周期图示</p>\n<ul>\n<li>实例化vue</li>\n<li>初始化事件驱动和生命周期</li>\n<li>初始化数据，运行环境</li>\n<li>判断参数列表是否存在el属性/vm.$mount(el)</li>\n<li>判断参数列表是否存在template属性<ul>\n<li>如果存在用template模板替换生成DOM</li>\n<li>如果不存在使用HTML中写好的DOM</li>\n</ul>\n</li>\n<li>创建vm.$el属性，插值表达式替换页面中的变量</li>\n<li>完成安装，同时创建虚拟DOM，时时更新页面</li>\n<li>卸载</li>\n</ul>\n</li>\n<li></li>\n<li><p>说白了就是vue实例创建的时候，触发了很多事件函数(vue.js自己写好的)，并且这些事件函数中提供了许多接口（callback），来供用户自定义一些自己的代码，加入vue实例创建的并调用他们</p>\n<ul>\n<li><pre><code class="language-html"> &lt;div id=&quot;app&quot;&gt;\n     {{message}}\n &lt;/div&gt;\n &lt;script&gt;\n     var vm = new Vue({\n         el:&#39;#app&#39;,\n         data:{\n             message:&#39;info&#39;\n         },\n         template:&#39;&lt;h2&gt;如果我存在，则会渲染我，不会渲染&lt;div id=&quot;app&quot;&gt;&lt;/&gt;&lt;/h2&gt;&#39;,\n         beforeCreate(){\n             console.log(this.$el)//undefined\n             console.log(this.$data)//undefined\n         },\n         create(){\n             console.log(this.$el)//undefined\n             console.log(this.$data)//{message:&#39;info&#39;}\n         },\n         beforeMount(){\n             console.log(this.$el)//存在，但没有用插值表达式替换数据\n             console.log(this.$data)//{message:&#39;info&#39;}\n         },\n         mounted(){\n             console.log(this.$el)//存在，插值表达式替换为真正数据\n             console.log(this.$data)//{message:&#39;info&#39;}\n         },\n         beforeUpdate(){\n             //更新数据之前调用（虚拟DOM发生了改变才会调用），但数据已经改变了\n             console.log(this.$data)//数据已经更新了\n             console.log(this.$el)//跟新的数据并没有渲染页面\n         },\n         update(){\n             //更新数据调用（虚拟DOM发生了改变才会调用）\n             console.log(this.$data)//数据已经更新了\n             console.log(this.$el)//视图重新渲染\n         },\n         boforeDestroy(){\n             //vm.$destroy 完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。 销毁时被调用\n             console.log(this.$data)//数据已经更新了\n             console.log(this.$el)//视图重新渲染\n         },\n         destroy(){\n             //vm.$destroy \n             console.log(this.$data)//数据已经更新了\n             console.log(this.$el)//视图重新渲染\n         }\n     })\n &lt;/script&gt;</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="vue-js-">Vue.js 组件</h2>\n<ul>\n<li><p>将一个大型项目切割成更小的可控单元（类似模块化开发）</p>\n</li>\n<li><p>组件是可复用，可维护的</p>\n</li>\n<li><p>组件具有强大的封装性</p>\n</li>\n<li><p>大型项目中，组件与组件中是可以解耦操作的</p>\n</li>\n<li><p>在beforeMount和mounted中的过程挂载，也就是挂载el元素的时候，在控制的vue元素标签上挂载了组件</p>\n</li>\n<li><p>组件继承了vue的实例，同样具有methods,watch,computed,等方法,同样具有生命周期</p>\n<ul>\n<li>但是组件中的data必须是函数</li>\n<li>因为组件是需要复用的，所以组件中的数据都应该有一个独立的作用域，不能影响其他数据</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>全局组件</p>\n<ul>\n<li><blockquote>\n<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;\n    &lt;my-header&gt;&lt;/my-header&gt;\n&lt;/div&gt;\n&lt;script&gt;\n    Vue.component(&#39;my-header&#39;,{\n        template:&#39;&lt;h2&gt;我是一个全局组件{{message}}&lt;/h2&gt;&#39;,\n        data(){\n            return {\n                message:&#39;haha&#39;\n            }\n        }\n    })\n\n    var vm = new Vue({\n        el:&#39;#app&#39;\n    })\n&lt;/script&gt;</code></pre>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>局部组件</p>\n<ul>\n<li><blockquote>\n<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;\n    &lt;my-header&gt;&lt;/my-header&gt;\n&lt;/div&gt;\n&lt;script&gt;\n\n    var vm = new Vue({\n        el:&#39;#app&#39;,\n        components:{\n             &#39;my-header&#39;:{\n                  template:&#39;&lt;h2&gt;我是一个局部组件{{message}}&lt;/h2&gt;&#39;,\n                 data(){\n                        return {\n                            message:&#39;haha&#39;\n                        }\n        }\n            },\n             &#39;my-list&#39;:{\n                template:&#39;&lt;h2&gt;我是一个局部组件&lt;/h2&gt;&#39;\n            }\n        }\n    })\n&lt;/script&gt;</code></pre>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>组件嵌套</p>\n<ul>\n<li><blockquote>\n<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;\n    &lt;my-header&gt;&lt;/my-header&gt;\n&lt;/div&gt;\n&lt;script&gt;\n\n    var vm = new Vue({\n        el:&#39;#app&#39;,\n        components:{\n             &#39;my-header&#39;:{\n                  template:&#39;&lt;h2&gt;我是一个局部组件{{message}},&lt;my-title&gt;&lt;my-title&gt;&lt;/h2&gt;&#39;,\n                 data(){\n                        return {\n                            message:&#39;haha&#39;\n                        }\n                        },\n                 components:{\n                     &#39;my-title&#39;:{\n                         template:&#39;&lt;h3&gt;我是一个嵌套的组件&lt;h3&gt;&#39;\n                     }\n                 }\n            },\n             &#39;my-list&#39;:{\n                template:&#39;&lt;h2&gt;我是一个局部组件&lt;/h2&gt;&#39;\n            }\n        }\n    })\n&lt;/script&gt;</code></pre>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="vue-js-">Vue.js 组件的模板方式</h3>\n<ul>\n<li><p>组件中的template必须有一个唯一的根元素</p>\n</li>\n<li><p>js字符串不能折行</p>\n<ul>\n<li>用  <strong>+</strong>  运算符进行连接</li>\n<li>用  <strong>\\</strong>  运算符进行连接（后面不能有space） </li>\n<li>用es6的模板字符串</li>\n</ul>\n</li>\n<li><p>利用<code>&lt;template&gt;</code>标签</p>\n<ul>\n<li><pre><code class="language-html">&lt;template id=&quot;tem&quot;&gt;\n    &lt;div&gt;\n        这里是vue的模板标签\n    &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    var vm = new Vue({\n        components:{\n            &#39;my-header&#39;:{\n                template:&#39;#item&#39;\n            }\n        }\n    })\n&lt;/script&gt;</code></pre>\n</li>\n</ul>\n</li>\n<li><p>利用<code>&lt;javascript type=&quot;text/x-template&quot;&gt;</code>标签</p>\n<ul>\n<li><pre><code class="language-html">&lt;javascript id=&quot;tem&quot; type=&quot;text/x-template&quot;&gt;\n    &lt;div&gt;\n        这里是vue的模板标签\n    &lt;/div&gt;\n&lt;/javascript&gt;\n\n&lt;script&gt;\n    var vm = new Vue({\n        components:{\n            &#39;my-header&#39;:{\n                template:&#39;#tem&#39;\n            }\n        }\n    })\n&lt;/script&gt;</code></pre>\n</li>\n</ul>\n</li>\n</ul>\n'},glLB:function(n,e){},gxlC:function(n,e){},hMVf:function(n,e){},hvcD:function(n,e){},nR5k:function(n,e){n.exports='<h1 id="vue-js-for-seven">Vue.js for seven</h1>\n<ul>\n<li>给vue.js添加所创建的网站添加一个可以通过ip来访问的方法<ul>\n<li>在package.json中的脚本中<code>dev</code>  添加  --host 0.0.0.0</li>\n</ul>\n</li>\n</ul>\n<h2 id="vue-js-">Vue.js项目上线</h2>\n<ul>\n<li><code>npm run build</code>创建一个dist文件</li>\n<li>后端解决反向代理接口问题</li>\n<li>将前端生成的文件分发给后端的文件夹<ul>\n<li>static放入public中</li>\n<li>index.html放到views文件夹中</li>\n<li>index.html 更名为index.ejs</li>\n</ul>\n</li>\n</ul>\n<h2 id="vue-js-">Vue.js自定义指令</h2>\n<ul>\n<li><pre><code class="language-html">Vue.directive()全局定义指令\ndirectives:{}局部定义指令</code></pre>\n</li>\n<li><pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;\n    &lt;div v-color=&quot;xxx&quot;&gt;\n        123\n    &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;script&gt;\n    var vm = new Vue({\n        el:&#39;#app&#39;,\n        directives:{\n            //定义一个v-color指令\n            &#39;color&#39;:{\n                 //指令里面有指令特有的生命周期\n                bind(){\n                    //绑定指令生命周期\n                },\n                inserted(el,binding){\n                    //指令插入完毕\n                    //每个指令接受两个参数，第一个参数为绑定指令的元素，第二个参数为绑定指令内的执行环境参数xxx\n                    el.style.background = binding.value\n                },\n                update(){\n                    //指令更新\n                    el.style.background = binding.value\n                },\n                componentUpdate(){\n                    //指令更新结束\n                },\n                unbind(){\n                    //指令解绑\n                }\n            }\n        }\n    })\n&lt;/script&gt;</code></pre>\n</li>\n<li><pre><code class="language-javascript">//当所有环境内容一样的时候，可以直接简写为\n&#39;color&#39;:function(el,binding){\n    el.style.background = binding.value\n}</code></pre>\n</li>\n</ul>\n<h2 id="vue-js-">Vue.js 过滤器</h2>\n<ul>\n<li><p>vue.js自带了很多过滤器，我们可以查文档，一般都是一些简单的函数</p>\n</li>\n<li><p>同样我们可以自定义过滤器</p>\n</li>\n<li><pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;\n    {{message | firstUpper | throudthed(&#39;xxx&#39;)}}\n    &lt;!----可以写多个过滤器----&gt;\n&lt;/div&gt;\n\n&lt;script&gt;\n    var vm = new Vue({\n        el:&#39;#app&#39;,\n        data:{\n            message:&#39;hello&#39;,\n            number:1231414123123\n        },\n        filters:{\n            firstUpper(val){\n                //在定义的数据后面写|过滤器函数名称 就会把数据传输给过滤器的参数中，我们就可以操作这个参数了\n                return val.slice(0,1).toUpperCase()+val.slice(1)\n            },\n            throudthed(val,rag){\n                //第二个参数为标签中传递过来的变量\n                return Number(val).toLocaleString()//转化千分符\n            }\n        }\n    })\n&lt;/script&gt;</code></pre>\n</li>\n</ul>\n<h2 id="vue-js-">Vue.js 的性能优化</h2>\n<ul>\n<li>key属性，可以添加到列表循环中提高性能</li>\n<li>keep-alive，可以利用这个标签对组件进行缓存处理，提高性能</li>\n<li>v-show，使用频繁的显示隐藏。提高性能</li>\n<li>异步组件可以改善中大型项目的加载</li>\n</ul>\n<h2 id="vue-js-">Vue.js异步组件</h2>\n<ul>\n<li><p>用到这个组件的时候，才会加载。用不到的时候，不会加载</p>\n</li>\n<li><p>适合中大型网站</p>\n</li>\n<li><p>不适合小型网站（产生额外的http请求）</p>\n</li>\n<li><pre><code class="language-js">//我们可以在配置路由时，或引入组件是这么写\ncompoent:()=&gt;import &#39;@components/xxxx&#39;\n//这样我们不就不会预加载所有组件，而是在我们请求这个组件是，才会引入这个组件</code></pre>\n</li>\n</ul>\n<h2 id="postman">POSTMAN</h2>\n<ul>\n<li>用来测试接口数据</li>\n<li>可以测试get/post等请求，且不需要写代码</li>\n</ul>\n<h2 id="-vue-js-ui-">基于Vue.js的UI框架</h2>\n<ul>\n<li><p>mint_ui（饿了么团队制作的移动端UI框架）</p>\n<ul>\n<li><p>基于vue框架使用</p>\n<ul>\n<li><p>可以通过npm下载【npm install -S mint_ui】</p>\n</li>\n<li><p>在main.js中引用直接,也可以像vuex一样，专门创建一个文件来配置。但这个模块配置比较简单，可以直接在main.js中配置</p>\n</li>\n<li><p>```js\nimport Vue from &#39;vue&#39;;\nimport mint from &#39;mint_ui&#39;;\nimport &#39;mint_ui/lib/style.css&#39;\nVue.use(mint);</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>  ```\n\n- 自带许多组件，自带样式。只要根据框架提供的语法，就可以直接使用\n\n  - 分为ui组件和js组件</code></pre><ul>\n<li><p>组件之间的引用</p>\n<ul>\n<li>父子组件之间的引用，子组件必须写在父组件的<code>template</code>属性中，否则不会渲染</li>\n<li>兄弟组件的引用，可以直接在自定义标签中引用，但注意外部组件的<code>template</code>属性中应该有插槽标签<slot></solt></li>\n</ul>\n</li>\n</ul>\n<h2 id="-vue-js-">深入 Vue.js 了解响应式原理</h2>\n<pre><code class="language-html">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;script&gt;\n    //正常创建一个对象\n    var obj = {\n        message : &#39;hello&#39;,\n        username : &#39;xiaoming&#39;\n    };\n\n    /*console.log( obj.message );\n\n    obj.message = &#39;hi&#39;;\n\n    delete obj.message;\n\n    console.log( obj.message );*/\n\n    /*for(var attr in obj){   //枚举操作\n        console.log(attr);\n    }*/\n\n    //Object.defineProperty() : 改变对象中属性的默认值\n\n    /*console.log(Object.getOwnPropertyDescriptor(obj, &#39;message&#39;));//列举一个对象属性的底层属性\n\n    { \n        value: &quot;hello&quot;, \n        writable: true, 是否可以读写\n        enumerable: true, 是否可以枚举\n        configurable: true    是否可以删除\n    }*/\n\n    //从js底层创建或修改一个对象属性  \n    Object.defineProperty(obj , &#39;age&#39; , {\n        value : 20,\n        //这里什么都不写，所有默认为false\n    }); \n\n    //console.log( obj );\n\n    //console.log(Object.getOwnPropertyDescriptor(obj, &#39;age&#39;));\n\n    obj.age = 30;\n\n    console.log( obj.age );\n\n\n\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre>\n'},oGTq:function(n,e){},oYyU:function(n,e){},"p1f+":function(n,e,t){n.exports=t.p+"static/img/transition.5990c1d.png"},pfIa:function(n,e){},rSm3:function(n,e){},yE95:function(n,e){},yIGO:function(n,e){},"yk+x":function(n,e){}},["NHnr"]);
//# sourceMappingURL=app.4ab9686c6c3df07f30b6.js.map